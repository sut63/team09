// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team09/app/ent/course"
	"github.com/team09/app/ent/department"
	"github.com/team09/app/ent/detail"
	"github.com/team09/app/ent/disease"
	"github.com/team09/app/ent/doctor"
	"github.com/team09/app/ent/extradoctor"
	"github.com/team09/app/ent/gender"
	"github.com/team09/app/ent/mission"
	"github.com/team09/app/ent/office"
	"github.com/team09/app/ent/position"
	"github.com/team09/app/ent/schedule"
	"github.com/team09/app/ent/specialdoctor"
	"github.com/team09/app/ent/title"
	"github.com/team09/app/ent/training"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse        = "Course"
	TypeDepartment    = "Department"
	TypeDetail        = "Detail"
	TypeDisease       = "Disease"
	TypeDoctor        = "Doctor"
	TypeExtradoctor   = "Extradoctor"
	TypeGender        = "Gender"
	TypeMission       = "Mission"
	TypeOffice        = "Office"
	TypePosition      = "Position"
	TypeSchedule      = "Schedule"
	TypeSpecialdoctor = "Specialdoctor"
	TypeTitle         = "Title"
	TypeTraining      = "Training"
)

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op               Op
	typ              string
	id               *int
	namecourse       *string
	clearedFields    map[string]struct{}
	trainings        map[int]struct{}
	removedtrainings map[int]struct{}
	details          map[int]struct{}
	removeddetails   map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNamecourse sets the namecourse field.
func (m *CourseMutation) SetNamecourse(s string) {
	m.namecourse = &s
}

// Namecourse returns the namecourse value in the mutation.
func (m *CourseMutation) Namecourse() (r string, exists bool) {
	v := m.namecourse
	if v == nil {
		return
	}
	return *v, true
}

// OldNamecourse returns the old namecourse value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldNamecourse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNamecourse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNamecourse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamecourse: %w", err)
	}
	return oldValue.Namecourse, nil
}

// ResetNamecourse reset all changes of the "namecourse" field.
func (m *CourseMutation) ResetNamecourse() {
	m.namecourse = nil
}

// AddTrainingIDs adds the trainings edge to Training by ids.
func (m *CourseMutation) AddTrainingIDs(ids ...int) {
	if m.trainings == nil {
		m.trainings = make(map[int]struct{})
	}
	for i := range ids {
		m.trainings[ids[i]] = struct{}{}
	}
}

// RemoveTrainingIDs removes the trainings edge to Training by ids.
func (m *CourseMutation) RemoveTrainingIDs(ids ...int) {
	if m.removedtrainings == nil {
		m.removedtrainings = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtrainings[ids[i]] = struct{}{}
	}
}

// RemovedTrainings returns the removed ids of trainings.
func (m *CourseMutation) RemovedTrainingsIDs() (ids []int) {
	for id := range m.removedtrainings {
		ids = append(ids, id)
	}
	return
}

// TrainingsIDs returns the trainings ids in the mutation.
func (m *CourseMutation) TrainingsIDs() (ids []int) {
	for id := range m.trainings {
		ids = append(ids, id)
	}
	return
}

// ResetTrainings reset all changes of the "trainings" edge.
func (m *CourseMutation) ResetTrainings() {
	m.trainings = nil
	m.removedtrainings = nil
}

// AddDetailIDs adds the details edge to Detail by ids.
func (m *CourseMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// RemoveDetailIDs removes the details edge to Detail by ids.
func (m *CourseMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed ids of details.
func (m *CourseMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the details ids in the mutation.
func (m *CourseMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails reset all changes of the "details" edge.
func (m *CourseMutation) ResetDetails() {
	m.details = nil
	m.removeddetails = nil
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.namecourse != nil {
		fields = append(fields, course.FieldNamecourse)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldNamecourse:
		return m.Namecourse()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldNamecourse:
		return m.OldNamecourse(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldNamecourse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamecourse(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldNamecourse:
		m.ResetNamecourse()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.trainings != nil {
		edges = append(edges, course.EdgeTrainings)
	}
	if m.details != nil {
		edges = append(edges, course.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.trainings))
		for id := range m.trainings {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtrainings != nil {
		edges = append(edges, course.EdgeTrainings)
	}
	if m.removeddetails != nil {
		edges = append(edges, course.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.removedtrainings))
		for id := range m.removedtrainings {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeTrainings:
		m.ResetTrainings()
		return nil
	case course.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_Name                 *string
	clearedFields         map[string]struct{}
	details               map[int]struct{}
	removeddetails        map[int]struct{}
	offices               map[int]struct{}
	removedoffices        map[int]struct{}
	schedules             map[int]struct{}
	removedschedules      map[int]struct{}
	trainings             map[int]struct{}
	removedtrainings      map[int]struct{}
	specialdoctors        map[int]struct{}
	removedspecialdoctors map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *DepartmentMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *DepartmentMutation) ResetName() {
	m._Name = nil
}

// AddDetailIDs adds the details edge to Detail by ids.
func (m *DepartmentMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// RemoveDetailIDs removes the details edge to Detail by ids.
func (m *DepartmentMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed ids of details.
func (m *DepartmentMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the details ids in the mutation.
func (m *DepartmentMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails reset all changes of the "details" edge.
func (m *DepartmentMutation) ResetDetails() {
	m.details = nil
	m.removeddetails = nil
}

// AddOfficeIDs adds the offices edge to Office by ids.
func (m *DepartmentMutation) AddOfficeIDs(ids ...int) {
	if m.offices == nil {
		m.offices = make(map[int]struct{})
	}
	for i := range ids {
		m.offices[ids[i]] = struct{}{}
	}
}

// RemoveOfficeIDs removes the offices edge to Office by ids.
func (m *DepartmentMutation) RemoveOfficeIDs(ids ...int) {
	if m.removedoffices == nil {
		m.removedoffices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoffices[ids[i]] = struct{}{}
	}
}

// RemovedOffices returns the removed ids of offices.
func (m *DepartmentMutation) RemovedOfficesIDs() (ids []int) {
	for id := range m.removedoffices {
		ids = append(ids, id)
	}
	return
}

// OfficesIDs returns the offices ids in the mutation.
func (m *DepartmentMutation) OfficesIDs() (ids []int) {
	for id := range m.offices {
		ids = append(ids, id)
	}
	return
}

// ResetOffices reset all changes of the "offices" edge.
func (m *DepartmentMutation) ResetOffices() {
	m.offices = nil
	m.removedoffices = nil
}

// AddScheduleIDs adds the schedules edge to Schedule by ids.
func (m *DepartmentMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// RemoveScheduleIDs removes the schedules edge to Schedule by ids.
func (m *DepartmentMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed ids of schedules.
func (m *DepartmentMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the schedules ids in the mutation.
func (m *DepartmentMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules reset all changes of the "schedules" edge.
func (m *DepartmentMutation) ResetSchedules() {
	m.schedules = nil
	m.removedschedules = nil
}

// AddTrainingIDs adds the trainings edge to Training by ids.
func (m *DepartmentMutation) AddTrainingIDs(ids ...int) {
	if m.trainings == nil {
		m.trainings = make(map[int]struct{})
	}
	for i := range ids {
		m.trainings[ids[i]] = struct{}{}
	}
}

// RemoveTrainingIDs removes the trainings edge to Training by ids.
func (m *DepartmentMutation) RemoveTrainingIDs(ids ...int) {
	if m.removedtrainings == nil {
		m.removedtrainings = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtrainings[ids[i]] = struct{}{}
	}
}

// RemovedTrainings returns the removed ids of trainings.
func (m *DepartmentMutation) RemovedTrainingsIDs() (ids []int) {
	for id := range m.removedtrainings {
		ids = append(ids, id)
	}
	return
}

// TrainingsIDs returns the trainings ids in the mutation.
func (m *DepartmentMutation) TrainingsIDs() (ids []int) {
	for id := range m.trainings {
		ids = append(ids, id)
	}
	return
}

// ResetTrainings reset all changes of the "trainings" edge.
func (m *DepartmentMutation) ResetTrainings() {
	m.trainings = nil
	m.removedtrainings = nil
}

// AddSpecialdoctorIDs adds the specialdoctors edge to Specialdoctor by ids.
func (m *DepartmentMutation) AddSpecialdoctorIDs(ids ...int) {
	if m.specialdoctors == nil {
		m.specialdoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.specialdoctors[ids[i]] = struct{}{}
	}
}

// RemoveSpecialdoctorIDs removes the specialdoctors edge to Specialdoctor by ids.
func (m *DepartmentMutation) RemoveSpecialdoctorIDs(ids ...int) {
	if m.removedspecialdoctors == nil {
		m.removedspecialdoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removedspecialdoctors[ids[i]] = struct{}{}
	}
}

// RemovedSpecialdoctors returns the removed ids of specialdoctors.
func (m *DepartmentMutation) RemovedSpecialdoctorsIDs() (ids []int) {
	for id := range m.removedspecialdoctors {
		ids = append(ids, id)
	}
	return
}

// SpecialdoctorsIDs returns the specialdoctors ids in the mutation.
func (m *DepartmentMutation) SpecialdoctorsIDs() (ids []int) {
	for id := range m.specialdoctors {
		ids = append(ids, id)
	}
	return
}

// ResetSpecialdoctors reset all changes of the "specialdoctors" edge.
func (m *DepartmentMutation) ResetSpecialdoctors() {
	m.specialdoctors = nil
	m.removedspecialdoctors = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, department.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.details != nil {
		edges = append(edges, department.EdgeDetails)
	}
	if m.offices != nil {
		edges = append(edges, department.EdgeOffices)
	}
	if m.schedules != nil {
		edges = append(edges, department.EdgeSchedules)
	}
	if m.trainings != nil {
		edges = append(edges, department.EdgeTrainings)
	}
	if m.specialdoctors != nil {
		edges = append(edges, department.EdgeSpecialdoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.offices))
		for id := range m.offices {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.trainings))
		for id := range m.trainings {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSpecialdoctors:
		ids := make([]ent.Value, 0, len(m.specialdoctors))
		for id := range m.specialdoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddetails != nil {
		edges = append(edges, department.EdgeDetails)
	}
	if m.removedoffices != nil {
		edges = append(edges, department.EdgeOffices)
	}
	if m.removedschedules != nil {
		edges = append(edges, department.EdgeSchedules)
	}
	if m.removedtrainings != nil {
		edges = append(edges, department.EdgeTrainings)
	}
	if m.removedspecialdoctors != nil {
		edges = append(edges, department.EdgeSpecialdoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.removedoffices))
		for id := range m.removedoffices {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.removedtrainings))
		for id := range m.removedtrainings {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSpecialdoctors:
		ids := make([]ent.Value, 0, len(m.removedspecialdoctors))
		for id := range m.removedspecialdoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDetails:
		m.ResetDetails()
		return nil
	case department.EdgeOffices:
		m.ResetOffices()
		return nil
	case department.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case department.EdgeTrainings:
		m.ResetTrainings()
		return nil
	case department.EdgeSpecialdoctors:
		m.ResetSpecialdoctors()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DetailMutation represents an operation that mutate the Details
// nodes in the graph.
type DetailMutation struct {
	config
	op                Op
	typ               string
	id                *int
	explain           *string
	phone             *string
	email             *string
	clearedFields     map[string]struct{}
	course            *int
	clearedcourse     bool
	mission           *int
	clearedmission    bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Detail, error)
}

var _ ent.Mutation = (*DetailMutation)(nil)

// detailOption allows to manage the mutation configuration using functional options.
type detailOption func(*DetailMutation)

// newDetailMutation creates new mutation for $n.Name.
func newDetailMutation(c config, op Op, opts ...detailOption) *DetailMutation {
	m := &DetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDetailID sets the id field of the mutation.
func withDetailID(id int) detailOption {
	return func(m *DetailMutation) {
		var (
			err   error
			once  sync.Once
			value *Detail
		)
		m.oldValue = func(ctx context.Context) (*Detail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Detail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDetail sets the old Detail of the mutation.
func withDetail(node *Detail) detailOption {
	return func(m *DetailMutation) {
		m.oldValue = func(context.Context) (*Detail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExplain sets the explain field.
func (m *DetailMutation) SetExplain(s string) {
	m.explain = &s
}

// Explain returns the explain value in the mutation.
func (m *DetailMutation) Explain() (r string, exists bool) {
	v := m.explain
	if v == nil {
		return
	}
	return *v, true
}

// OldExplain returns the old explain value of the Detail.
// If the Detail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DetailMutation) OldExplain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExplain is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExplain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplain: %w", err)
	}
	return oldValue.Explain, nil
}

// ResetExplain reset all changes of the "explain" field.
func (m *DetailMutation) ResetExplain() {
	m.explain = nil
}

// SetPhone sets the phone field.
func (m *DetailMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *DetailMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Detail.
// If the Detail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DetailMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *DetailMutation) ResetPhone() {
	m.phone = nil
}

// SetEmail sets the email field.
func (m *DetailMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *DetailMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Detail.
// If the Detail object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DetailMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *DetailMutation) ResetEmail() {
	m.email = nil
}

// SetCourseID sets the course edge to Course by id.
func (m *DetailMutation) SetCourseID(id int) {
	m.course = &id
}

// ClearCourse clears the course edge to Course.
func (m *DetailMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared returns if the edge course was cleared.
func (m *DetailMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the course id in the mutation.
func (m *DetailMutation) CourseID() (id int, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the course ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *DetailMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse reset all changes of the "course" edge.
func (m *DetailMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetMissionID sets the mission edge to Mission by id.
func (m *DetailMutation) SetMissionID(id int) {
	m.mission = &id
}

// ClearMission clears the mission edge to Mission.
func (m *DetailMutation) ClearMission() {
	m.clearedmission = true
}

// MissionCleared returns if the edge mission was cleared.
func (m *DetailMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionID returns the mission id in the mutation.
func (m *DetailMutation) MissionID() (id int, exists bool) {
	if m.mission != nil {
		return *m.mission, true
	}
	return
}

// MissionIDs returns the mission ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *DetailMutation) MissionIDs() (ids []int) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission reset all changes of the "mission" edge.
func (m *DetailMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *DetailMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *DetailMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *DetailMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *DetailMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *DetailMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *DetailMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Op returns the operation name.
func (m *DetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Detail).
func (m *DetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DetailMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.explain != nil {
		fields = append(fields, detail.FieldExplain)
	}
	if m.phone != nil {
		fields = append(fields, detail.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, detail.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case detail.FieldExplain:
		return m.Explain()
	case detail.FieldPhone:
		return m.Phone()
	case detail.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case detail.FieldExplain:
		return m.OldExplain(ctx)
	case detail.FieldPhone:
		return m.OldPhone(ctx)
	case detail.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Detail field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case detail.FieldExplain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplain(v)
		return nil
	case detail.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case detail.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Detail field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Detail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Detail nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DetailMutation) ResetField(name string) error {
	switch name {
	case detail.FieldExplain:
		m.ResetExplain()
		return nil
	case detail.FieldPhone:
		m.ResetPhone()
		return nil
	case detail.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Detail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, detail.EdgeCourse)
	}
	if m.mission != nil {
		edges = append(edges, detail.EdgeMission)
	}
	if m.department != nil {
		edges = append(edges, detail.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case detail.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case detail.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case detail.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, detail.EdgeCourse)
	}
	if m.clearedmission {
		edges = append(edges, detail.EdgeMission)
	}
	if m.cleareddepartment {
		edges = append(edges, detail.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DetailMutation) EdgeCleared(name string) bool {
	switch name {
	case detail.EdgeCourse:
		return m.clearedcourse
	case detail.EdgeMission:
		return m.clearedmission
	case detail.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DetailMutation) ClearEdge(name string) error {
	switch name {
	case detail.EdgeCourse:
		m.ClearCourse()
		return nil
	case detail.EdgeMission:
		m.ClearMission()
		return nil
	case detail.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Detail unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DetailMutation) ResetEdge(name string) error {
	switch name {
	case detail.EdgeCourse:
		m.ResetCourse()
		return nil
	case detail.EdgeMission:
		m.ResetMission()
		return nil
	case detail.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Detail edge %s", name)
}

// DiseaseMutation represents an operation that mutate the Diseases
// nodes in the graph.
type DiseaseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	disease        *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Disease, error)
}

var _ ent.Mutation = (*DiseaseMutation)(nil)

// diseaseOption allows to manage the mutation configuration using functional options.
type diseaseOption func(*DiseaseMutation)

// newDiseaseMutation creates new mutation for $n.Name.
func newDiseaseMutation(c config, op Op, opts ...diseaseOption) *DiseaseMutation {
	m := &DiseaseMutation{
		config:        c,
		op:            op,
		typ:           TypeDisease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiseaseID sets the id field of the mutation.
func withDiseaseID(id int) diseaseOption {
	return func(m *DiseaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Disease
		)
		m.oldValue = func(ctx context.Context) (*Disease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisease sets the old Disease of the mutation.
func withDisease(node *Disease) diseaseOption {
	return func(m *DiseaseMutation) {
		m.oldValue = func(context.Context) (*Disease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiseaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiseaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DiseaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDisease sets the disease field.
func (m *DiseaseMutation) SetDisease(s string) {
	m.disease = &s
}

// Disease returns the disease value in the mutation.
func (m *DiseaseMutation) Disease() (r string, exists bool) {
	v := m.disease
	if v == nil {
		return
	}
	return *v, true
}

// OldDisease returns the old disease value of the Disease.
// If the Disease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseMutation) OldDisease(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisease is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisease: %w", err)
	}
	return oldValue.Disease, nil
}

// ResetDisease reset all changes of the "disease" field.
func (m *DiseaseMutation) ResetDisease() {
	m.disease = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *DiseaseMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *DiseaseMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *DiseaseMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *DiseaseMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *DiseaseMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *DiseaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disease).
func (m *DiseaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DiseaseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.disease != nil {
		fields = append(fields, disease.FieldDisease)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DiseaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disease.FieldDisease:
		return m.Disease()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DiseaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disease.FieldDisease:
		return m.OldDisease(ctx)
	}
	return nil, fmt.Errorf("unknown Disease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disease.FieldDisease:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisease(v)
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DiseaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DiseaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DiseaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DiseaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiseaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DiseaseMutation) ResetField(name string) error {
	switch name {
	case disease.FieldDisease:
		m.ResetDisease()
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DiseaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, disease.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DiseaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DiseaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, disease.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DiseaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DiseaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DiseaseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DiseaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DiseaseMutation) ResetEdge(name string) error {
	switch name {
	case disease.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Disease edge %s", name)
}

// DoctorMutation represents an operation that mutate the Doctors
// nodes in the graph.
type DoctorMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	age                   *int
	addage                *int
	email                 *string
	password              *string
	address               *string
	educational           *string
	phone                 *string
	clearedFields         map[string]struct{}
	title                 *int
	clearedtitle          bool
	gender                *int
	clearedgender         bool
	position              *int
	clearedposition       bool
	disease               *int
	cleareddisease        bool
	offices               map[int]struct{}
	removedoffices        map[int]struct{}
	departments           map[int]struct{}
	removeddepartments    map[int]struct{}
	schedules             map[int]struct{}
	removedschedules      map[int]struct{}
	trainings             map[int]struct{}
	removedtrainings      map[int]struct{}
	specialdoctors        map[int]struct{}
	removedspecialdoctors map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Doctor, error)
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows to manage the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for $n.Name.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the id field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DoctorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DoctorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DoctorMutation) ResetName() {
	m.name = nil
}

// SetAge sets the age field.
func (m *DoctorMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *DoctorMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *DoctorMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *DoctorMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "age" field.
func (m *DoctorMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetEmail sets the email field.
func (m *DoctorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *DoctorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *DoctorMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *DoctorMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *DoctorMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *DoctorMutation) ResetPassword() {
	m.password = nil
}

// SetAddress sets the address field.
func (m *DoctorMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *DoctorMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *DoctorMutation) ResetAddress() {
	m.address = nil
}

// SetEducational sets the educational field.
func (m *DoctorMutation) SetEducational(s string) {
	m.educational = &s
}

// Educational returns the educational value in the mutation.
func (m *DoctorMutation) Educational() (r string, exists bool) {
	v := m.educational
	if v == nil {
		return
	}
	return *v, true
}

// OldEducational returns the old educational value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldEducational(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEducational is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEducational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducational: %w", err)
	}
	return oldValue.Educational, nil
}

// ResetEducational reset all changes of the "educational" field.
func (m *DoctorMutation) ResetEducational() {
	m.educational = nil
}

// SetPhone sets the phone field.
func (m *DoctorMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *DoctorMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *DoctorMutation) ResetPhone() {
	m.phone = nil
}

// SetTitleID sets the title edge to Title by id.
func (m *DoctorMutation) SetTitleID(id int) {
	m.title = &id
}

// ClearTitle clears the title edge to Title.
func (m *DoctorMutation) ClearTitle() {
	m.clearedtitle = true
}

// TitleCleared returns if the edge title was cleared.
func (m *DoctorMutation) TitleCleared() bool {
	return m.clearedtitle
}

// TitleID returns the title id in the mutation.
func (m *DoctorMutation) TitleID() (id int, exists bool) {
	if m.title != nil {
		return *m.title, true
	}
	return
}

// TitleIDs returns the title ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TitleID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) TitleIDs() (ids []int) {
	if id := m.title; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTitle reset all changes of the "title" edge.
func (m *DoctorMutation) ResetTitle() {
	m.title = nil
	m.clearedtitle = false
}

// SetGenderID sets the gender edge to Gender by id.
func (m *DoctorMutation) SetGenderID(id int) {
	m.gender = &id
}

// ClearGender clears the gender edge to Gender.
func (m *DoctorMutation) ClearGender() {
	m.clearedgender = true
}

// GenderCleared returns if the edge gender was cleared.
func (m *DoctorMutation) GenderCleared() bool {
	return m.clearedgender
}

// GenderID returns the gender id in the mutation.
func (m *DoctorMutation) GenderID() (id int, exists bool) {
	if m.gender != nil {
		return *m.gender, true
	}
	return
}

// GenderIDs returns the gender ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) GenderIDs() (ids []int) {
	if id := m.gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender reset all changes of the "gender" edge.
func (m *DoctorMutation) ResetGender() {
	m.gender = nil
	m.clearedgender = false
}

// SetPositionID sets the position edge to Position by id.
func (m *DoctorMutation) SetPositionID(id int) {
	m.position = &id
}

// ClearPosition clears the position edge to Position.
func (m *DoctorMutation) ClearPosition() {
	m.clearedposition = true
}

// PositionCleared returns if the edge position was cleared.
func (m *DoctorMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionID returns the position id in the mutation.
func (m *DoctorMutation) PositionID() (id int, exists bool) {
	if m.position != nil {
		return *m.position, true
	}
	return
}

// PositionIDs returns the position ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) PositionIDs() (ids []int) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition reset all changes of the "position" edge.
func (m *DoctorMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// SetDiseaseID sets the disease edge to Disease by id.
func (m *DoctorMutation) SetDiseaseID(id int) {
	m.disease = &id
}

// ClearDisease clears the disease edge to Disease.
func (m *DoctorMutation) ClearDisease() {
	m.cleareddisease = true
}

// DiseaseCleared returns if the edge disease was cleared.
func (m *DoctorMutation) DiseaseCleared() bool {
	return m.cleareddisease
}

// DiseaseID returns the disease id in the mutation.
func (m *DoctorMutation) DiseaseID() (id int, exists bool) {
	if m.disease != nil {
		return *m.disease, true
	}
	return
}

// DiseaseIDs returns the disease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DiseaseID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) DiseaseIDs() (ids []int) {
	if id := m.disease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDisease reset all changes of the "disease" edge.
func (m *DoctorMutation) ResetDisease() {
	m.disease = nil
	m.cleareddisease = false
}

// AddOfficeIDs adds the offices edge to Office by ids.
func (m *DoctorMutation) AddOfficeIDs(ids ...int) {
	if m.offices == nil {
		m.offices = make(map[int]struct{})
	}
	for i := range ids {
		m.offices[ids[i]] = struct{}{}
	}
}

// RemoveOfficeIDs removes the offices edge to Office by ids.
func (m *DoctorMutation) RemoveOfficeIDs(ids ...int) {
	if m.removedoffices == nil {
		m.removedoffices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoffices[ids[i]] = struct{}{}
	}
}

// RemovedOffices returns the removed ids of offices.
func (m *DoctorMutation) RemovedOfficesIDs() (ids []int) {
	for id := range m.removedoffices {
		ids = append(ids, id)
	}
	return
}

// OfficesIDs returns the offices ids in the mutation.
func (m *DoctorMutation) OfficesIDs() (ids []int) {
	for id := range m.offices {
		ids = append(ids, id)
	}
	return
}

// ResetOffices reset all changes of the "offices" edge.
func (m *DoctorMutation) ResetOffices() {
	m.offices = nil
	m.removedoffices = nil
}

// AddDepartmentIDs adds the departments edge to Department by ids.
func (m *DoctorMutation) AddDepartmentIDs(ids ...int) {
	if m.departments == nil {
		m.departments = make(map[int]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentIDs removes the departments edge to Department by ids.
func (m *DoctorMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed ids of departments.
func (m *DoctorMutation) RemovedDepartmentsIDs() (ids []int) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the departments ids in the mutation.
func (m *DoctorMutation) DepartmentsIDs() (ids []int) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments reset all changes of the "departments" edge.
func (m *DoctorMutation) ResetDepartments() {
	m.departments = nil
	m.removeddepartments = nil
}

// AddScheduleIDs adds the schedules edge to Schedule by ids.
func (m *DoctorMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// RemoveScheduleIDs removes the schedules edge to Schedule by ids.
func (m *DoctorMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed ids of schedules.
func (m *DoctorMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the schedules ids in the mutation.
func (m *DoctorMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules reset all changes of the "schedules" edge.
func (m *DoctorMutation) ResetSchedules() {
	m.schedules = nil
	m.removedschedules = nil
}

// AddTrainingIDs adds the trainings edge to Training by ids.
func (m *DoctorMutation) AddTrainingIDs(ids ...int) {
	if m.trainings == nil {
		m.trainings = make(map[int]struct{})
	}
	for i := range ids {
		m.trainings[ids[i]] = struct{}{}
	}
}

// RemoveTrainingIDs removes the trainings edge to Training by ids.
func (m *DoctorMutation) RemoveTrainingIDs(ids ...int) {
	if m.removedtrainings == nil {
		m.removedtrainings = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtrainings[ids[i]] = struct{}{}
	}
}

// RemovedTrainings returns the removed ids of trainings.
func (m *DoctorMutation) RemovedTrainingsIDs() (ids []int) {
	for id := range m.removedtrainings {
		ids = append(ids, id)
	}
	return
}

// TrainingsIDs returns the trainings ids in the mutation.
func (m *DoctorMutation) TrainingsIDs() (ids []int) {
	for id := range m.trainings {
		ids = append(ids, id)
	}
	return
}

// ResetTrainings reset all changes of the "trainings" edge.
func (m *DoctorMutation) ResetTrainings() {
	m.trainings = nil
	m.removedtrainings = nil
}

// AddSpecialdoctorIDs adds the specialdoctors edge to Specialdoctor by ids.
func (m *DoctorMutation) AddSpecialdoctorIDs(ids ...int) {
	if m.specialdoctors == nil {
		m.specialdoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.specialdoctors[ids[i]] = struct{}{}
	}
}

// RemoveSpecialdoctorIDs removes the specialdoctors edge to Specialdoctor by ids.
func (m *DoctorMutation) RemoveSpecialdoctorIDs(ids ...int) {
	if m.removedspecialdoctors == nil {
		m.removedspecialdoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removedspecialdoctors[ids[i]] = struct{}{}
	}
}

// RemovedSpecialdoctors returns the removed ids of specialdoctors.
func (m *DoctorMutation) RemovedSpecialdoctorsIDs() (ids []int) {
	for id := range m.removedspecialdoctors {
		ids = append(ids, id)
	}
	return
}

// SpecialdoctorsIDs returns the specialdoctors ids in the mutation.
func (m *DoctorMutation) SpecialdoctorsIDs() (ids []int) {
	for id := range m.specialdoctors {
		ids = append(ids, id)
	}
	return
}

// ResetSpecialdoctors reset all changes of the "specialdoctors" edge.
func (m *DoctorMutation) ResetSpecialdoctors() {
	m.specialdoctors = nil
	m.removedspecialdoctors = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, doctor.FieldName)
	}
	if m.age != nil {
		fields = append(fields, doctor.FieldAge)
	}
	if m.email != nil {
		fields = append(fields, doctor.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, doctor.FieldPassword)
	}
	if m.address != nil {
		fields = append(fields, doctor.FieldAddress)
	}
	if m.educational != nil {
		fields = append(fields, doctor.FieldEducational)
	}
	if m.phone != nil {
		fields = append(fields, doctor.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldName:
		return m.Name()
	case doctor.FieldAge:
		return m.Age()
	case doctor.FieldEmail:
		return m.Email()
	case doctor.FieldPassword:
		return m.Password()
	case doctor.FieldAddress:
		return m.Address()
	case doctor.FieldEducational:
		return m.Educational()
	case doctor.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldName:
		return m.OldName(ctx)
	case doctor.FieldAge:
		return m.OldAge(ctx)
	case doctor.FieldEmail:
		return m.OldEmail(ctx)
	case doctor.FieldPassword:
		return m.OldPassword(ctx)
	case doctor.FieldAddress:
		return m.OldAddress(ctx)
	case doctor.FieldEducational:
		return m.OldEducational(ctx)
	case doctor.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case doctor.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case doctor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case doctor.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case doctor.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case doctor.FieldEducational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducational(v)
		return nil
	case doctor.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, doctor.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldName:
		m.ResetName()
		return nil
	case doctor.FieldAge:
		m.ResetAge()
		return nil
	case doctor.FieldEmail:
		m.ResetEmail()
		return nil
	case doctor.FieldPassword:
		m.ResetPassword()
		return nil
	case doctor.FieldAddress:
		m.ResetAddress()
		return nil
	case doctor.FieldEducational:
		m.ResetEducational()
		return nil
	case doctor.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.title != nil {
		edges = append(edges, doctor.EdgeTitle)
	}
	if m.gender != nil {
		edges = append(edges, doctor.EdgeGender)
	}
	if m.position != nil {
		edges = append(edges, doctor.EdgePosition)
	}
	if m.disease != nil {
		edges = append(edges, doctor.EdgeDisease)
	}
	if m.offices != nil {
		edges = append(edges, doctor.EdgeOffices)
	}
	if m.departments != nil {
		edges = append(edges, doctor.EdgeDepartments)
	}
	if m.schedules != nil {
		edges = append(edges, doctor.EdgeSchedules)
	}
	if m.trainings != nil {
		edges = append(edges, doctor.EdgeTrainings)
	}
	if m.specialdoctors != nil {
		edges = append(edges, doctor.EdgeSpecialdoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeTitle:
		if id := m.title; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeGender:
		if id := m.gender; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeDisease:
		if id := m.disease; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.offices))
		for id := range m.offices {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.trainings))
		for id := range m.trainings {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSpecialdoctors:
		ids := make([]ent.Value, 0, len(m.specialdoctors))
		for id := range m.specialdoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedoffices != nil {
		edges = append(edges, doctor.EdgeOffices)
	}
	if m.removeddepartments != nil {
		edges = append(edges, doctor.EdgeDepartments)
	}
	if m.removedschedules != nil {
		edges = append(edges, doctor.EdgeSchedules)
	}
	if m.removedtrainings != nil {
		edges = append(edges, doctor.EdgeTrainings)
	}
	if m.removedspecialdoctors != nil {
		edges = append(edges, doctor.EdgeSpecialdoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.removedoffices))
		for id := range m.removedoffices {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.removedtrainings))
		for id := range m.removedtrainings {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSpecialdoctors:
		ids := make([]ent.Value, 0, len(m.removedspecialdoctors))
		for id := range m.removedspecialdoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedtitle {
		edges = append(edges, doctor.EdgeTitle)
	}
	if m.clearedgender {
		edges = append(edges, doctor.EdgeGender)
	}
	if m.clearedposition {
		edges = append(edges, doctor.EdgePosition)
	}
	if m.cleareddisease {
		edges = append(edges, doctor.EdgeDisease)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgeTitle:
		return m.clearedtitle
	case doctor.EdgeGender:
		return m.clearedgender
	case doctor.EdgePosition:
		return m.clearedposition
	case doctor.EdgeDisease:
		return m.cleareddisease
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	case doctor.EdgeTitle:
		m.ClearTitle()
		return nil
	case doctor.EdgeGender:
		m.ClearGender()
		return nil
	case doctor.EdgePosition:
		m.ClearPosition()
		return nil
	case doctor.EdgeDisease:
		m.ClearDisease()
		return nil
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeTitle:
		m.ResetTitle()
		return nil
	case doctor.EdgeGender:
		m.ResetGender()
		return nil
	case doctor.EdgePosition:
		m.ResetPosition()
		return nil
	case doctor.EdgeDisease:
		m.ResetDisease()
		return nil
	case doctor.EdgeOffices:
		m.ResetOffices()
		return nil
	case doctor.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case doctor.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case doctor.EdgeTrainings:
		m.ResetTrainings()
		return nil
	case doctor.EdgeSpecialdoctors:
		m.ResetSpecialdoctors()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// ExtradoctorMutation represents an operation that mutate the Extradoctors
// nodes in the graph.
type ExtradoctorMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	specialname           *string
	clearedFields         map[string]struct{}
	specialdoctors        map[int]struct{}
	removedspecialdoctors map[int]struct{}
	offices               map[int]struct{}
	removedoffices        map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Extradoctor, error)
}

var _ ent.Mutation = (*ExtradoctorMutation)(nil)

// extradoctorOption allows to manage the mutation configuration using functional options.
type extradoctorOption func(*ExtradoctorMutation)

// newExtradoctorMutation creates new mutation for $n.Name.
func newExtradoctorMutation(c config, op Op, opts ...extradoctorOption) *ExtradoctorMutation {
	m := &ExtradoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeExtradoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExtradoctorID sets the id field of the mutation.
func withExtradoctorID(id int) extradoctorOption {
	return func(m *ExtradoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Extradoctor
		)
		m.oldValue = func(ctx context.Context) (*Extradoctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Extradoctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExtradoctor sets the old Extradoctor of the mutation.
func withExtradoctor(node *Extradoctor) extradoctorOption {
	return func(m *ExtradoctorMutation) {
		m.oldValue = func(context.Context) (*Extradoctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExtradoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExtradoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ExtradoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpecialname sets the specialname field.
func (m *ExtradoctorMutation) SetSpecialname(s string) {
	m.specialname = &s
}

// Specialname returns the specialname value in the mutation.
func (m *ExtradoctorMutation) Specialname() (r string, exists bool) {
	v := m.specialname
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialname returns the old specialname value of the Extradoctor.
// If the Extradoctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExtradoctorMutation) OldSpecialname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialname: %w", err)
	}
	return oldValue.Specialname, nil
}

// ResetSpecialname reset all changes of the "specialname" field.
func (m *ExtradoctorMutation) ResetSpecialname() {
	m.specialname = nil
}

// AddSpecialdoctorIDs adds the specialdoctors edge to Specialdoctor by ids.
func (m *ExtradoctorMutation) AddSpecialdoctorIDs(ids ...int) {
	if m.specialdoctors == nil {
		m.specialdoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.specialdoctors[ids[i]] = struct{}{}
	}
}

// RemoveSpecialdoctorIDs removes the specialdoctors edge to Specialdoctor by ids.
func (m *ExtradoctorMutation) RemoveSpecialdoctorIDs(ids ...int) {
	if m.removedspecialdoctors == nil {
		m.removedspecialdoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removedspecialdoctors[ids[i]] = struct{}{}
	}
}

// RemovedSpecialdoctors returns the removed ids of specialdoctors.
func (m *ExtradoctorMutation) RemovedSpecialdoctorsIDs() (ids []int) {
	for id := range m.removedspecialdoctors {
		ids = append(ids, id)
	}
	return
}

// SpecialdoctorsIDs returns the specialdoctors ids in the mutation.
func (m *ExtradoctorMutation) SpecialdoctorsIDs() (ids []int) {
	for id := range m.specialdoctors {
		ids = append(ids, id)
	}
	return
}

// ResetSpecialdoctors reset all changes of the "specialdoctors" edge.
func (m *ExtradoctorMutation) ResetSpecialdoctors() {
	m.specialdoctors = nil
	m.removedspecialdoctors = nil
}

// AddOfficeIDs adds the offices edge to Office by ids.
func (m *ExtradoctorMutation) AddOfficeIDs(ids ...int) {
	if m.offices == nil {
		m.offices = make(map[int]struct{})
	}
	for i := range ids {
		m.offices[ids[i]] = struct{}{}
	}
}

// RemoveOfficeIDs removes the offices edge to Office by ids.
func (m *ExtradoctorMutation) RemoveOfficeIDs(ids ...int) {
	if m.removedoffices == nil {
		m.removedoffices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoffices[ids[i]] = struct{}{}
	}
}

// RemovedOffices returns the removed ids of offices.
func (m *ExtradoctorMutation) RemovedOfficesIDs() (ids []int) {
	for id := range m.removedoffices {
		ids = append(ids, id)
	}
	return
}

// OfficesIDs returns the offices ids in the mutation.
func (m *ExtradoctorMutation) OfficesIDs() (ids []int) {
	for id := range m.offices {
		ids = append(ids, id)
	}
	return
}

// ResetOffices reset all changes of the "offices" edge.
func (m *ExtradoctorMutation) ResetOffices() {
	m.offices = nil
	m.removedoffices = nil
}

// Op returns the operation name.
func (m *ExtradoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Extradoctor).
func (m *ExtradoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ExtradoctorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.specialname != nil {
		fields = append(fields, extradoctor.FieldSpecialname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ExtradoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case extradoctor.FieldSpecialname:
		return m.Specialname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ExtradoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case extradoctor.FieldSpecialname:
		return m.OldSpecialname(ctx)
	}
	return nil, fmt.Errorf("unknown Extradoctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExtradoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case extradoctor.FieldSpecialname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialname(v)
		return nil
	}
	return fmt.Errorf("unknown Extradoctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ExtradoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ExtradoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExtradoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Extradoctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ExtradoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ExtradoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExtradoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Extradoctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ExtradoctorMutation) ResetField(name string) error {
	switch name {
	case extradoctor.FieldSpecialname:
		m.ResetSpecialname()
		return nil
	}
	return fmt.Errorf("unknown Extradoctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ExtradoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.specialdoctors != nil {
		edges = append(edges, extradoctor.EdgeSpecialdoctors)
	}
	if m.offices != nil {
		edges = append(edges, extradoctor.EdgeOffices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ExtradoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case extradoctor.EdgeSpecialdoctors:
		ids := make([]ent.Value, 0, len(m.specialdoctors))
		for id := range m.specialdoctors {
			ids = append(ids, id)
		}
		return ids
	case extradoctor.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.offices))
		for id := range m.offices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ExtradoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedspecialdoctors != nil {
		edges = append(edges, extradoctor.EdgeSpecialdoctors)
	}
	if m.removedoffices != nil {
		edges = append(edges, extradoctor.EdgeOffices)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ExtradoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case extradoctor.EdgeSpecialdoctors:
		ids := make([]ent.Value, 0, len(m.removedspecialdoctors))
		for id := range m.removedspecialdoctors {
			ids = append(ids, id)
		}
		return ids
	case extradoctor.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.removedoffices))
		for id := range m.removedoffices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ExtradoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ExtradoctorMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ExtradoctorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Extradoctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ExtradoctorMutation) ResetEdge(name string) error {
	switch name {
	case extradoctor.EdgeSpecialdoctors:
		m.ResetSpecialdoctors()
		return nil
	case extradoctor.EdgeOffices:
		m.ResetOffices()
		return nil
	}
	return fmt.Errorf("unknown Extradoctor edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op             Op
	typ            string
	id             *int
	gender         *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGender sets the gender field.
func (m *GenderMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the gender value in the mutation.
func (m *GenderMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *GenderMutation) ResetGender() {
	m.gender = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *GenderMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *GenderMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *GenderMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *GenderMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *GenderMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.gender != nil {
		fields = append(fields, gender.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, gender.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, gender.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// MissionMutation represents an operation that mutate the Missions
// nodes in the graph.
type MissionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	mission            *string
	clearedFields      map[string]struct{}
	departments        map[int]struct{}
	removeddepartments map[int]struct{}
	details            map[int]struct{}
	removeddetails     map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Mission, error)
}

var _ ent.Mutation = (*MissionMutation)(nil)

// missionOption allows to manage the mutation configuration using functional options.
type missionOption func(*MissionMutation)

// newMissionMutation creates new mutation for $n.Name.
func newMissionMutation(c config, op Op, opts ...missionOption) *MissionMutation {
	m := &MissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionID sets the id field of the mutation.
func withMissionID(id int) missionOption {
	return func(m *MissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Mission
		)
		m.oldValue = func(ctx context.Context) (*Mission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMission sets the old Mission of the mutation.
func withMission(node *Mission) missionOption {
	return func(m *MissionMutation) {
		m.oldValue = func(context.Context) (*Mission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMission sets the mission field.
func (m *MissionMutation) SetMission(s string) {
	m.mission = &s
}

// Mission returns the mission value in the mutation.
func (m *MissionMutation) Mission() (r string, exists bool) {
	v := m.mission
	if v == nil {
		return
	}
	return *v, true
}

// OldMission returns the old mission value of the Mission.
// If the Mission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MissionMutation) OldMission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMission is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMission: %w", err)
	}
	return oldValue.Mission, nil
}

// ResetMission reset all changes of the "mission" field.
func (m *MissionMutation) ResetMission() {
	m.mission = nil
}

// AddDepartmentIDs adds the departments edge to Department by ids.
func (m *MissionMutation) AddDepartmentIDs(ids ...int) {
	if m.departments == nil {
		m.departments = make(map[int]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentIDs removes the departments edge to Department by ids.
func (m *MissionMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed ids of departments.
func (m *MissionMutation) RemovedDepartmentsIDs() (ids []int) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the departments ids in the mutation.
func (m *MissionMutation) DepartmentsIDs() (ids []int) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments reset all changes of the "departments" edge.
func (m *MissionMutation) ResetDepartments() {
	m.departments = nil
	m.removeddepartments = nil
}

// AddDetailIDs adds the details edge to Detail by ids.
func (m *MissionMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// RemoveDetailIDs removes the details edge to Detail by ids.
func (m *MissionMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed ids of details.
func (m *MissionMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the details ids in the mutation.
func (m *MissionMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails reset all changes of the "details" edge.
func (m *MissionMutation) ResetDetails() {
	m.details = nil
	m.removeddetails = nil
}

// Op returns the operation name.
func (m *MissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Mission).
func (m *MissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MissionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.mission != nil {
		fields = append(fields, mission.FieldMission)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldMission:
		return m.Mission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mission.FieldMission:
		return m.OldMission(ctx)
	}
	return nil, fmt.Errorf("unknown Mission field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mission.FieldMission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMission(v)
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Mission nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MissionMutation) ResetField(name string) error {
	switch name {
	case mission.FieldMission:
		m.ResetMission()
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.departments != nil {
		edges = append(edges, mission.EdgeDepartments)
	}
	if m.details != nil {
		edges = append(edges, mission.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddepartments != nil {
		edges = append(edges, mission.EdgeDepartments)
	}
	if m.removeddetails != nil {
		edges = append(edges, mission.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case mission.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MissionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Mission unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MissionMutation) ResetEdge(name string) error {
	switch name {
	case mission.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case mission.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Mission edge %s", name)
}

// OfficeMutation represents an operation that mutate the Offices
// nodes in the graph.
type OfficeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	officename         *string
	roomnumber         *string
	doctoridcard       *string
	firsttime          *time.Time
	finallytime        *time.Time
	clearedFields      map[string]struct{}
	doctor             *int
	cleareddoctor      bool
	department         *int
	cleareddepartment  bool
	extradoctor        *int
	clearedextradoctor bool
	schedules          map[int]struct{}
	removedschedules   map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Office, error)
}

var _ ent.Mutation = (*OfficeMutation)(nil)

// officeOption allows to manage the mutation configuration using functional options.
type officeOption func(*OfficeMutation)

// newOfficeMutation creates new mutation for $n.Name.
func newOfficeMutation(c config, op Op, opts ...officeOption) *OfficeMutation {
	m := &OfficeMutation{
		config:        c,
		op:            op,
		typ:           TypeOffice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOfficeID sets the id field of the mutation.
func withOfficeID(id int) officeOption {
	return func(m *OfficeMutation) {
		var (
			err   error
			once  sync.Once
			value *Office
		)
		m.oldValue = func(ctx context.Context) (*Office, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Office.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOffice sets the old Office of the mutation.
func withOffice(node *Office) officeOption {
	return func(m *OfficeMutation) {
		m.oldValue = func(context.Context) (*Office, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OfficeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OfficeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OfficeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOfficename sets the officename field.
func (m *OfficeMutation) SetOfficename(s string) {
	m.officename = &s
}

// Officename returns the officename value in the mutation.
func (m *OfficeMutation) Officename() (r string, exists bool) {
	v := m.officename
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficename returns the old officename value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldOfficename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfficename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfficename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficename: %w", err)
	}
	return oldValue.Officename, nil
}

// ResetOfficename reset all changes of the "officename" field.
func (m *OfficeMutation) ResetOfficename() {
	m.officename = nil
}

// SetRoomnumber sets the roomnumber field.
func (m *OfficeMutation) SetRoomnumber(s string) {
	m.roomnumber = &s
}

// Roomnumber returns the roomnumber value in the mutation.
func (m *OfficeMutation) Roomnumber() (r string, exists bool) {
	v := m.roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old roomnumber value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "roomnumber" field.
func (m *OfficeMutation) ResetRoomnumber() {
	m.roomnumber = nil
}

// SetDoctoridcard sets the doctoridcard field.
func (m *OfficeMutation) SetDoctoridcard(s string) {
	m.doctoridcard = &s
}

// Doctoridcard returns the doctoridcard value in the mutation.
func (m *OfficeMutation) Doctoridcard() (r string, exists bool) {
	v := m.doctoridcard
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctoridcard returns the old doctoridcard value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldDoctoridcard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctoridcard is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctoridcard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctoridcard: %w", err)
	}
	return oldValue.Doctoridcard, nil
}

// ResetDoctoridcard reset all changes of the "doctoridcard" field.
func (m *OfficeMutation) ResetDoctoridcard() {
	m.doctoridcard = nil
}

// SetFirsttime sets the firsttime field.
func (m *OfficeMutation) SetFirsttime(t time.Time) {
	m.firsttime = &t
}

// Firsttime returns the firsttime value in the mutation.
func (m *OfficeMutation) Firsttime() (r time.Time, exists bool) {
	v := m.firsttime
	if v == nil {
		return
	}
	return *v, true
}

// OldFirsttime returns the old firsttime value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldFirsttime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirsttime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirsttime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirsttime: %w", err)
	}
	return oldValue.Firsttime, nil
}

// ResetFirsttime reset all changes of the "firsttime" field.
func (m *OfficeMutation) ResetFirsttime() {
	m.firsttime = nil
}

// SetFinallytime sets the finallytime field.
func (m *OfficeMutation) SetFinallytime(t time.Time) {
	m.finallytime = &t
}

// Finallytime returns the finallytime value in the mutation.
func (m *OfficeMutation) Finallytime() (r time.Time, exists bool) {
	v := m.finallytime
	if v == nil {
		return
	}
	return *v, true
}

// OldFinallytime returns the old finallytime value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldFinallytime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinallytime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinallytime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinallytime: %w", err)
	}
	return oldValue.Finallytime, nil
}

// ResetFinallytime reset all changes of the "finallytime" field.
func (m *OfficeMutation) ResetFinallytime() {
	m.finallytime = nil
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *OfficeMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *OfficeMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *OfficeMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *OfficeMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *OfficeMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *OfficeMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *OfficeMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *OfficeMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *OfficeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *OfficeMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *OfficeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *OfficeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetExtradoctorID sets the extradoctor edge to Extradoctor by id.
func (m *OfficeMutation) SetExtradoctorID(id int) {
	m.extradoctor = &id
}

// ClearExtradoctor clears the extradoctor edge to Extradoctor.
func (m *OfficeMutation) ClearExtradoctor() {
	m.clearedextradoctor = true
}

// ExtradoctorCleared returns if the edge extradoctor was cleared.
func (m *OfficeMutation) ExtradoctorCleared() bool {
	return m.clearedextradoctor
}

// ExtradoctorID returns the extradoctor id in the mutation.
func (m *OfficeMutation) ExtradoctorID() (id int, exists bool) {
	if m.extradoctor != nil {
		return *m.extradoctor, true
	}
	return
}

// ExtradoctorIDs returns the extradoctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ExtradoctorID instead. It exists only for internal usage by the builders.
func (m *OfficeMutation) ExtradoctorIDs() (ids []int) {
	if id := m.extradoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtradoctor reset all changes of the "extradoctor" edge.
func (m *OfficeMutation) ResetExtradoctor() {
	m.extradoctor = nil
	m.clearedextradoctor = false
}

// AddScheduleIDs adds the schedules edge to Schedule by ids.
func (m *OfficeMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// RemoveScheduleIDs removes the schedules edge to Schedule by ids.
func (m *OfficeMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed ids of schedules.
func (m *OfficeMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the schedules ids in the mutation.
func (m *OfficeMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules reset all changes of the "schedules" edge.
func (m *OfficeMutation) ResetSchedules() {
	m.schedules = nil
	m.removedschedules = nil
}

// Op returns the operation name.
func (m *OfficeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Office).
func (m *OfficeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OfficeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.officename != nil {
		fields = append(fields, office.FieldOfficename)
	}
	if m.roomnumber != nil {
		fields = append(fields, office.FieldRoomnumber)
	}
	if m.doctoridcard != nil {
		fields = append(fields, office.FieldDoctoridcard)
	}
	if m.firsttime != nil {
		fields = append(fields, office.FieldFirsttime)
	}
	if m.finallytime != nil {
		fields = append(fields, office.FieldFinallytime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OfficeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case office.FieldOfficename:
		return m.Officename()
	case office.FieldRoomnumber:
		return m.Roomnumber()
	case office.FieldDoctoridcard:
		return m.Doctoridcard()
	case office.FieldFirsttime:
		return m.Firsttime()
	case office.FieldFinallytime:
		return m.Finallytime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OfficeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case office.FieldOfficename:
		return m.OldOfficename(ctx)
	case office.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	case office.FieldDoctoridcard:
		return m.OldDoctoridcard(ctx)
	case office.FieldFirsttime:
		return m.OldFirsttime(ctx)
	case office.FieldFinallytime:
		return m.OldFinallytime(ctx)
	}
	return nil, fmt.Errorf("unknown Office field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case office.FieldOfficename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficename(v)
		return nil
	case office.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	case office.FieldDoctoridcard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctoridcard(v)
		return nil
	case office.FieldFirsttime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirsttime(v)
		return nil
	case office.FieldFinallytime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinallytime(v)
		return nil
	}
	return fmt.Errorf("unknown Office field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OfficeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OfficeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Office numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OfficeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OfficeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OfficeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Office nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OfficeMutation) ResetField(name string) error {
	switch name {
	case office.FieldOfficename:
		m.ResetOfficename()
		return nil
	case office.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	case office.FieldDoctoridcard:
		m.ResetDoctoridcard()
		return nil
	case office.FieldFirsttime:
		m.ResetFirsttime()
		return nil
	case office.FieldFinallytime:
		m.ResetFinallytime()
		return nil
	}
	return fmt.Errorf("unknown Office field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OfficeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.doctor != nil {
		edges = append(edges, office.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, office.EdgeDepartment)
	}
	if m.extradoctor != nil {
		edges = append(edges, office.EdgeExtradoctor)
	}
	if m.schedules != nil {
		edges = append(edges, office.EdgeSchedules)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OfficeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case office.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case office.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case office.EdgeExtradoctor:
		if id := m.extradoctor; id != nil {
			return []ent.Value{*id}
		}
	case office.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OfficeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedschedules != nil {
		edges = append(edges, office.EdgeSchedules)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OfficeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case office.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OfficeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddoctor {
		edges = append(edges, office.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, office.EdgeDepartment)
	}
	if m.clearedextradoctor {
		edges = append(edges, office.EdgeExtradoctor)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OfficeMutation) EdgeCleared(name string) bool {
	switch name {
	case office.EdgeDoctor:
		return m.cleareddoctor
	case office.EdgeDepartment:
		return m.cleareddepartment
	case office.EdgeExtradoctor:
		return m.clearedextradoctor
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OfficeMutation) ClearEdge(name string) error {
	switch name {
	case office.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case office.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case office.EdgeExtradoctor:
		m.ClearExtradoctor()
		return nil
	}
	return fmt.Errorf("unknown Office unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OfficeMutation) ResetEdge(name string) error {
	switch name {
	case office.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case office.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case office.EdgeExtradoctor:
		m.ResetExtradoctor()
		return nil
	case office.EdgeSchedules:
		m.ResetSchedules()
		return nil
	}
	return fmt.Errorf("unknown Office edge %s", name)
}

// PositionMutation represents an operation that mutate the Positions
// nodes in the graph.
type PositionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	position       *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Position, error)
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows to manage the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for $n.Name.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the id field of the mutation.
func withPositionID(id int) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPosition sets the position field.
func (m *PositionMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the position value in the mutation.
func (m *PositionMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old position value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPosition is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition reset all changes of the "position" field.
func (m *PositionMutation) ResetPosition() {
	m.position = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *PositionMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *PositionMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *PositionMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *PositionMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *PositionMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.position != nil {
		fields = append(fields, position.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldPosition:
		return m.OldPosition(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, position.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, position.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// ScheduleMutation represents an operation that mutate the Schedules
// nodes in the graph.
type ScheduleMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Activity         *string
	_Roomnumber       *string
	_Docterid         *string
	added_time        *time.Time
	clearedFields     map[string]struct{}
	doctor            *int
	cleareddoctor     bool
	department        *int
	cleareddepartment bool
	office            *int
	clearedoffice     bool
	done              bool
	oldValue          func(context.Context) (*Schedule, error)
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows to manage the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for $n.Name.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the id field of the mutation.
func withScheduleID(id int) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetActivity sets the Activity field.
func (m *ScheduleMutation) SetActivity(s string) {
	m._Activity = &s
}

// Activity returns the Activity value in the mutation.
func (m *ScheduleMutation) Activity() (r string, exists bool) {
	v := m._Activity
	if v == nil {
		return
	}
	return *v, true
}

// OldActivity returns the old Activity value of the Schedule.
// If the Schedule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScheduleMutation) OldActivity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivity: %w", err)
	}
	return oldValue.Activity, nil
}

// ResetActivity reset all changes of the "Activity" field.
func (m *ScheduleMutation) ResetActivity() {
	m._Activity = nil
}

// SetRoomnumber sets the Roomnumber field.
func (m *ScheduleMutation) SetRoomnumber(s string) {
	m._Roomnumber = &s
}

// Roomnumber returns the Roomnumber value in the mutation.
func (m *ScheduleMutation) Roomnumber() (r string, exists bool) {
	v := m._Roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old Roomnumber value of the Schedule.
// If the Schedule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScheduleMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "Roomnumber" field.
func (m *ScheduleMutation) ResetRoomnumber() {
	m._Roomnumber = nil
}

// SetDocterid sets the Docterid field.
func (m *ScheduleMutation) SetDocterid(s string) {
	m._Docterid = &s
}

// Docterid returns the Docterid value in the mutation.
func (m *ScheduleMutation) Docterid() (r string, exists bool) {
	v := m._Docterid
	if v == nil {
		return
	}
	return *v, true
}

// OldDocterid returns the old Docterid value of the Schedule.
// If the Schedule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScheduleMutation) OldDocterid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDocterid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDocterid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocterid: %w", err)
	}
	return oldValue.Docterid, nil
}

// ResetDocterid reset all changes of the "Docterid" field.
func (m *ScheduleMutation) ResetDocterid() {
	m._Docterid = nil
}

// SetAddedTime sets the added_time field.
func (m *ScheduleMutation) SetAddedTime(t time.Time) {
	m.added_time = &t
}

// AddedTime returns the added_time value in the mutation.
func (m *ScheduleMutation) AddedTime() (r time.Time, exists bool) {
	v := m.added_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime returns the old added_time value of the Schedule.
// If the Schedule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScheduleMutation) OldAddedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime: %w", err)
	}
	return oldValue.AddedTime, nil
}

// ResetAddedTime reset all changes of the "added_time" field.
func (m *ScheduleMutation) ResetAddedTime() {
	m.added_time = nil
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *ScheduleMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *ScheduleMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *ScheduleMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *ScheduleMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *ScheduleMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *ScheduleMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *ScheduleMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *ScheduleMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *ScheduleMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *ScheduleMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetOfficeID sets the office edge to Office by id.
func (m *ScheduleMutation) SetOfficeID(id int) {
	m.office = &id
}

// ClearOffice clears the office edge to Office.
func (m *ScheduleMutation) ClearOffice() {
	m.clearedoffice = true
}

// OfficeCleared returns if the edge office was cleared.
func (m *ScheduleMutation) OfficeCleared() bool {
	return m.clearedoffice
}

// OfficeID returns the office id in the mutation.
func (m *ScheduleMutation) OfficeID() (id int, exists bool) {
	if m.office != nil {
		return *m.office, true
	}
	return
}

// OfficeIDs returns the office ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OfficeID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) OfficeIDs() (ids []int) {
	if id := m.office; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOffice reset all changes of the "office" edge.
func (m *ScheduleMutation) ResetOffice() {
	m.office = nil
	m.clearedoffice = false
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Activity != nil {
		fields = append(fields, schedule.FieldActivity)
	}
	if m._Roomnumber != nil {
		fields = append(fields, schedule.FieldRoomnumber)
	}
	if m._Docterid != nil {
		fields = append(fields, schedule.FieldDocterid)
	}
	if m.added_time != nil {
		fields = append(fields, schedule.FieldAddedTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldActivity:
		return m.Activity()
	case schedule.FieldRoomnumber:
		return m.Roomnumber()
	case schedule.FieldDocterid:
		return m.Docterid()
	case schedule.FieldAddedTime:
		return m.AddedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldActivity:
		return m.OldActivity(ctx)
	case schedule.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	case schedule.FieldDocterid:
		return m.OldDocterid(ctx)
	case schedule.FieldAddedTime:
		return m.OldAddedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldActivity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivity(v)
		return nil
	case schedule.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	case schedule.FieldDocterid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocterid(v)
		return nil
	case schedule.FieldAddedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldActivity:
		m.ResetActivity()
		return nil
	case schedule.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	case schedule.FieldDocterid:
		m.ResetDocterid()
		return nil
	case schedule.FieldAddedTime:
		m.ResetAddedTime()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.doctor != nil {
		edges = append(edges, schedule.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, schedule.EdgeDepartment)
	}
	if m.office != nil {
		edges = append(edges, schedule.EdgeOffice)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case schedule.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case schedule.EdgeOffice:
		if id := m.office; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddoctor {
		edges = append(edges, schedule.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, schedule.EdgeDepartment)
	}
	if m.clearedoffice {
		edges = append(edges, schedule.EdgeOffice)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeDoctor:
		return m.cleareddoctor
	case schedule.EdgeDepartment:
		return m.cleareddepartment
	case schedule.EdgeOffice:
		return m.clearedoffice
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	case schedule.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case schedule.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case schedule.EdgeOffice:
		m.ClearOffice()
		return nil
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case schedule.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case schedule.EdgeOffice:
		m.ResetOffice()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// SpecialdoctorMutation represents an operation that mutate the Specialdoctors
// nodes in the graph.
type SpecialdoctorMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Roomnumber        *string
	_Doctorid          *string
	_Other             *string
	clearedFields      map[string]struct{}
	doctor             *int
	cleareddoctor      bool
	department         *int
	cleareddepartment  bool
	extradoctor        *int
	clearedextradoctor bool
	done               bool
	oldValue           func(context.Context) (*Specialdoctor, error)
}

var _ ent.Mutation = (*SpecialdoctorMutation)(nil)

// specialdoctorOption allows to manage the mutation configuration using functional options.
type specialdoctorOption func(*SpecialdoctorMutation)

// newSpecialdoctorMutation creates new mutation for $n.Name.
func newSpecialdoctorMutation(c config, op Op, opts ...specialdoctorOption) *SpecialdoctorMutation {
	m := &SpecialdoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecialdoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecialdoctorID sets the id field of the mutation.
func withSpecialdoctorID(id int) specialdoctorOption {
	return func(m *SpecialdoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Specialdoctor
		)
		m.oldValue = func(ctx context.Context) (*Specialdoctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Specialdoctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecialdoctor sets the old Specialdoctor of the mutation.
func withSpecialdoctor(node *Specialdoctor) specialdoctorOption {
	return func(m *SpecialdoctorMutation) {
		m.oldValue = func(context.Context) (*Specialdoctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecialdoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecialdoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SpecialdoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoomnumber sets the Roomnumber field.
func (m *SpecialdoctorMutation) SetRoomnumber(s string) {
	m._Roomnumber = &s
}

// Roomnumber returns the Roomnumber value in the mutation.
func (m *SpecialdoctorMutation) Roomnumber() (r string, exists bool) {
	v := m._Roomnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomnumber returns the old Roomnumber value of the Specialdoctor.
// If the Specialdoctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SpecialdoctorMutation) OldRoomnumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoomnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoomnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomnumber: %w", err)
	}
	return oldValue.Roomnumber, nil
}

// ResetRoomnumber reset all changes of the "Roomnumber" field.
func (m *SpecialdoctorMutation) ResetRoomnumber() {
	m._Roomnumber = nil
}

// SetDoctorid sets the Doctorid field.
func (m *SpecialdoctorMutation) SetDoctorid(s string) {
	m._Doctorid = &s
}

// Doctorid returns the Doctorid value in the mutation.
func (m *SpecialdoctorMutation) Doctorid() (r string, exists bool) {
	v := m._Doctorid
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorid returns the old Doctorid value of the Specialdoctor.
// If the Specialdoctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SpecialdoctorMutation) OldDoctorid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorid: %w", err)
	}
	return oldValue.Doctorid, nil
}

// ResetDoctorid reset all changes of the "Doctorid" field.
func (m *SpecialdoctorMutation) ResetDoctorid() {
	m._Doctorid = nil
}

// SetOther sets the Other field.
func (m *SpecialdoctorMutation) SetOther(s string) {
	m._Other = &s
}

// Other returns the Other value in the mutation.
func (m *SpecialdoctorMutation) Other() (r string, exists bool) {
	v := m._Other
	if v == nil {
		return
	}
	return *v, true
}

// OldOther returns the old Other value of the Specialdoctor.
// If the Specialdoctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SpecialdoctorMutation) OldOther(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOther is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOther: %w", err)
	}
	return oldValue.Other, nil
}

// ResetOther reset all changes of the "Other" field.
func (m *SpecialdoctorMutation) ResetOther() {
	m._Other = nil
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *SpecialdoctorMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *SpecialdoctorMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *SpecialdoctorMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *SpecialdoctorMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *SpecialdoctorMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *SpecialdoctorMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *SpecialdoctorMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *SpecialdoctorMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *SpecialdoctorMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *SpecialdoctorMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *SpecialdoctorMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *SpecialdoctorMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetExtradoctorID sets the extradoctor edge to Extradoctor by id.
func (m *SpecialdoctorMutation) SetExtradoctorID(id int) {
	m.extradoctor = &id
}

// ClearExtradoctor clears the extradoctor edge to Extradoctor.
func (m *SpecialdoctorMutation) ClearExtradoctor() {
	m.clearedextradoctor = true
}

// ExtradoctorCleared returns if the edge extradoctor was cleared.
func (m *SpecialdoctorMutation) ExtradoctorCleared() bool {
	return m.clearedextradoctor
}

// ExtradoctorID returns the extradoctor id in the mutation.
func (m *SpecialdoctorMutation) ExtradoctorID() (id int, exists bool) {
	if m.extradoctor != nil {
		return *m.extradoctor, true
	}
	return
}

// ExtradoctorIDs returns the extradoctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ExtradoctorID instead. It exists only for internal usage by the builders.
func (m *SpecialdoctorMutation) ExtradoctorIDs() (ids []int) {
	if id := m.extradoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExtradoctor reset all changes of the "extradoctor" edge.
func (m *SpecialdoctorMutation) ResetExtradoctor() {
	m.extradoctor = nil
	m.clearedextradoctor = false
}

// Op returns the operation name.
func (m *SpecialdoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Specialdoctor).
func (m *SpecialdoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SpecialdoctorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Roomnumber != nil {
		fields = append(fields, specialdoctor.FieldRoomnumber)
	}
	if m._Doctorid != nil {
		fields = append(fields, specialdoctor.FieldDoctorid)
	}
	if m._Other != nil {
		fields = append(fields, specialdoctor.FieldOther)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SpecialdoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case specialdoctor.FieldRoomnumber:
		return m.Roomnumber()
	case specialdoctor.FieldDoctorid:
		return m.Doctorid()
	case specialdoctor.FieldOther:
		return m.Other()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SpecialdoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case specialdoctor.FieldRoomnumber:
		return m.OldRoomnumber(ctx)
	case specialdoctor.FieldDoctorid:
		return m.OldDoctorid(ctx)
	case specialdoctor.FieldOther:
		return m.OldOther(ctx)
	}
	return nil, fmt.Errorf("unknown Specialdoctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SpecialdoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case specialdoctor.FieldRoomnumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomnumber(v)
		return nil
	case specialdoctor.FieldDoctorid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorid(v)
		return nil
	case specialdoctor.FieldOther:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOther(v)
		return nil
	}
	return fmt.Errorf("unknown Specialdoctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SpecialdoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SpecialdoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SpecialdoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Specialdoctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SpecialdoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SpecialdoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecialdoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Specialdoctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SpecialdoctorMutation) ResetField(name string) error {
	switch name {
	case specialdoctor.FieldRoomnumber:
		m.ResetRoomnumber()
		return nil
	case specialdoctor.FieldDoctorid:
		m.ResetDoctorid()
		return nil
	case specialdoctor.FieldOther:
		m.ResetOther()
		return nil
	}
	return fmt.Errorf("unknown Specialdoctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SpecialdoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.doctor != nil {
		edges = append(edges, specialdoctor.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, specialdoctor.EdgeDepartment)
	}
	if m.extradoctor != nil {
		edges = append(edges, specialdoctor.EdgeExtradoctor)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SpecialdoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case specialdoctor.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case specialdoctor.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case specialdoctor.EdgeExtradoctor:
		if id := m.extradoctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SpecialdoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SpecialdoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SpecialdoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddoctor {
		edges = append(edges, specialdoctor.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, specialdoctor.EdgeDepartment)
	}
	if m.clearedextradoctor {
		edges = append(edges, specialdoctor.EdgeExtradoctor)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SpecialdoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case specialdoctor.EdgeDoctor:
		return m.cleareddoctor
	case specialdoctor.EdgeDepartment:
		return m.cleareddepartment
	case specialdoctor.EdgeExtradoctor:
		return m.clearedextradoctor
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SpecialdoctorMutation) ClearEdge(name string) error {
	switch name {
	case specialdoctor.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case specialdoctor.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case specialdoctor.EdgeExtradoctor:
		m.ClearExtradoctor()
		return nil
	}
	return fmt.Errorf("unknown Specialdoctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SpecialdoctorMutation) ResetEdge(name string) error {
	switch name {
	case specialdoctor.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case specialdoctor.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case specialdoctor.EdgeExtradoctor:
		m.ResetExtradoctor()
		return nil
	}
	return fmt.Errorf("unknown Specialdoctor edge %s", name)
}

// TitleMutation represents an operation that mutate the Titles
// nodes in the graph.
type TitleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	title          *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Title, error)
}

var _ ent.Mutation = (*TitleMutation)(nil)

// titleOption allows to manage the mutation configuration using functional options.
type titleOption func(*TitleMutation)

// newTitleMutation creates new mutation for $n.Name.
func newTitleMutation(c config, op Op, opts ...titleOption) *TitleMutation {
	m := &TitleMutation{
		config:        c,
		op:            op,
		typ:           TypeTitle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTitleID sets the id field of the mutation.
func withTitleID(id int) titleOption {
	return func(m *TitleMutation) {
		var (
			err   error
			once  sync.Once
			value *Title
		)
		m.oldValue = func(ctx context.Context) (*Title, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Title.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTitle sets the old Title of the mutation.
func withTitle(node *Title) titleOption {
	return func(m *TitleMutation) {
		m.oldValue = func(context.Context) (*Title, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TitleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TitleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TitleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTitle sets the title field.
func (m *TitleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *TitleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the Title.
// If the Title object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TitleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *TitleMutation) ResetTitle() {
	m.title = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *TitleMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *TitleMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *TitleMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *TitleMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *TitleMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *TitleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Title).
func (m *TitleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TitleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.title != nil {
		fields = append(fields, title.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TitleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case title.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TitleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case title.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Title field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case title.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TitleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TitleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Title numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TitleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TitleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TitleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Title nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TitleMutation) ResetField(name string) error {
	switch name {
	case title.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TitleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, title.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TitleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TitleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, title.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TitleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TitleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TitleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TitleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Title unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TitleMutation) ResetEdge(name string) error {
	switch name {
	case title.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Title edge %s", name)
}

// TrainingMutation represents an operation that mutate the Trainings
// nodes in the graph.
type TrainingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	branch            *string
	dateone           *time.Time
	datetwo           *time.Time
	doctoridcard      *string
	hour              *int
	addhour           *int
	clearedFields     map[string]struct{}
	course            *int
	clearedcourse     bool
	doctor            *int
	cleareddoctor     bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Training, error)
}

var _ ent.Mutation = (*TrainingMutation)(nil)

// trainingOption allows to manage the mutation configuration using functional options.
type trainingOption func(*TrainingMutation)

// newTrainingMutation creates new mutation for $n.Name.
func newTrainingMutation(c config, op Op, opts ...trainingOption) *TrainingMutation {
	m := &TrainingMutation{
		config:        c,
		op:            op,
		typ:           TypeTraining,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainingID sets the id field of the mutation.
func withTrainingID(id int) trainingOption {
	return func(m *TrainingMutation) {
		var (
			err   error
			once  sync.Once
			value *Training
		)
		m.oldValue = func(ctx context.Context) (*Training, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Training.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTraining sets the old Training of the mutation.
func withTraining(node *Training) trainingOption {
	return func(m *TrainingMutation) {
		m.oldValue = func(context.Context) (*Training, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TrainingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBranch sets the branch field.
func (m *TrainingMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the branch value in the mutation.
func (m *TrainingMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old branch value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch reset all changes of the "branch" field.
func (m *TrainingMutation) ResetBranch() {
	m.branch = nil
}

// SetDateone sets the dateone field.
func (m *TrainingMutation) SetDateone(t time.Time) {
	m.dateone = &t
}

// Dateone returns the dateone value in the mutation.
func (m *TrainingMutation) Dateone() (r time.Time, exists bool) {
	v := m.dateone
	if v == nil {
		return
	}
	return *v, true
}

// OldDateone returns the old dateone value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldDateone(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateone: %w", err)
	}
	return oldValue.Dateone, nil
}

// ResetDateone reset all changes of the "dateone" field.
func (m *TrainingMutation) ResetDateone() {
	m.dateone = nil
}

// SetDatetwo sets the datetwo field.
func (m *TrainingMutation) SetDatetwo(t time.Time) {
	m.datetwo = &t
}

// Datetwo returns the datetwo value in the mutation.
func (m *TrainingMutation) Datetwo() (r time.Time, exists bool) {
	v := m.datetwo
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetwo returns the old datetwo value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldDatetwo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetwo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetwo: %w", err)
	}
	return oldValue.Datetwo, nil
}

// ResetDatetwo reset all changes of the "datetwo" field.
func (m *TrainingMutation) ResetDatetwo() {
	m.datetwo = nil
}

// SetDoctoridcard sets the doctoridcard field.
func (m *TrainingMutation) SetDoctoridcard(s string) {
	m.doctoridcard = &s
}

// Doctoridcard returns the doctoridcard value in the mutation.
func (m *TrainingMutation) Doctoridcard() (r string, exists bool) {
	v := m.doctoridcard
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctoridcard returns the old doctoridcard value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldDoctoridcard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctoridcard is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctoridcard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctoridcard: %w", err)
	}
	return oldValue.Doctoridcard, nil
}

// ResetDoctoridcard reset all changes of the "doctoridcard" field.
func (m *TrainingMutation) ResetDoctoridcard() {
	m.doctoridcard = nil
}

// SetHour sets the hour field.
func (m *TrainingMutation) SetHour(i int) {
	m.hour = &i
	m.addhour = nil
}

// Hour returns the hour value in the mutation.
func (m *TrainingMutation) Hour() (r int, exists bool) {
	v := m.hour
	if v == nil {
		return
	}
	return *v, true
}

// OldHour returns the old hour value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHour is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHour: %w", err)
	}
	return oldValue.Hour, nil
}

// AddHour adds i to hour.
func (m *TrainingMutation) AddHour(i int) {
	if m.addhour != nil {
		*m.addhour += i
	} else {
		m.addhour = &i
	}
}

// AddedHour returns the value that was added to the hour field in this mutation.
func (m *TrainingMutation) AddedHour() (r int, exists bool) {
	v := m.addhour
	if v == nil {
		return
	}
	return *v, true
}

// ResetHour reset all changes of the "hour" field.
func (m *TrainingMutation) ResetHour() {
	m.hour = nil
	m.addhour = nil
}

// SetCourseID sets the course edge to Course by id.
func (m *TrainingMutation) SetCourseID(id int) {
	m.course = &id
}

// ClearCourse clears the course edge to Course.
func (m *TrainingMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared returns if the edge course was cleared.
func (m *TrainingMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the course id in the mutation.
func (m *TrainingMutation) CourseID() (id int, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the course ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *TrainingMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse reset all changes of the "course" edge.
func (m *TrainingMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *TrainingMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *TrainingMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *TrainingMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *TrainingMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *TrainingMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *TrainingMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *TrainingMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *TrainingMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *TrainingMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *TrainingMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *TrainingMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *TrainingMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Op returns the operation name.
func (m *TrainingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Training).
func (m *TrainingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TrainingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.branch != nil {
		fields = append(fields, training.FieldBranch)
	}
	if m.dateone != nil {
		fields = append(fields, training.FieldDateone)
	}
	if m.datetwo != nil {
		fields = append(fields, training.FieldDatetwo)
	}
	if m.doctoridcard != nil {
		fields = append(fields, training.FieldDoctoridcard)
	}
	if m.hour != nil {
		fields = append(fields, training.FieldHour)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TrainingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case training.FieldBranch:
		return m.Branch()
	case training.FieldDateone:
		return m.Dateone()
	case training.FieldDatetwo:
		return m.Datetwo()
	case training.FieldDoctoridcard:
		return m.Doctoridcard()
	case training.FieldHour:
		return m.Hour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TrainingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case training.FieldBranch:
		return m.OldBranch(ctx)
	case training.FieldDateone:
		return m.OldDateone(ctx)
	case training.FieldDatetwo:
		return m.OldDatetwo(ctx)
	case training.FieldDoctoridcard:
		return m.OldDoctoridcard(ctx)
	case training.FieldHour:
		return m.OldHour(ctx)
	}
	return nil, fmt.Errorf("unknown Training field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TrainingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case training.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case training.FieldDateone:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateone(v)
		return nil
	case training.FieldDatetwo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetwo(v)
		return nil
	case training.FieldDoctoridcard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctoridcard(v)
		return nil
	case training.FieldHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHour(v)
		return nil
	}
	return fmt.Errorf("unknown Training field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TrainingMutation) AddedFields() []string {
	var fields []string
	if m.addhour != nil {
		fields = append(fields, training.FieldHour)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TrainingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case training.FieldHour:
		return m.AddedHour()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TrainingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case training.FieldHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHour(v)
		return nil
	}
	return fmt.Errorf("unknown Training numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TrainingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TrainingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Training nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TrainingMutation) ResetField(name string) error {
	switch name {
	case training.FieldBranch:
		m.ResetBranch()
		return nil
	case training.FieldDateone:
		m.ResetDateone()
		return nil
	case training.FieldDatetwo:
		m.ResetDatetwo()
		return nil
	case training.FieldDoctoridcard:
		m.ResetDoctoridcard()
		return nil
	case training.FieldHour:
		m.ResetHour()
		return nil
	}
	return fmt.Errorf("unknown Training field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TrainingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, training.EdgeCourse)
	}
	if m.doctor != nil {
		edges = append(edges, training.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, training.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TrainingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case training.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case training.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case training.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TrainingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TrainingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TrainingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, training.EdgeCourse)
	}
	if m.cleareddoctor {
		edges = append(edges, training.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, training.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TrainingMutation) EdgeCleared(name string) bool {
	switch name {
	case training.EdgeCourse:
		return m.clearedcourse
	case training.EdgeDoctor:
		return m.cleareddoctor
	case training.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TrainingMutation) ClearEdge(name string) error {
	switch name {
	case training.EdgeCourse:
		m.ClearCourse()
		return nil
	case training.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case training.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Training unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TrainingMutation) ResetEdge(name string) error {
	switch name {
	case training.EdgeCourse:
		m.ResetCourse()
		return nil
	case training.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case training.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Training edge %s", name)
}
