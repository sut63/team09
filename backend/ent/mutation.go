// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team09/app/ent/course"
	"github.com/team09/app/ent/department"
	"github.com/team09/app/ent/disease"
	"github.com/team09/app/ent/doctor"
	"github.com/team09/app/ent/gender"
	"github.com/team09/app/ent/mission"
	"github.com/team09/app/ent/office"
	"github.com/team09/app/ent/position"
	"github.com/team09/app/ent/schedule"
	"github.com/team09/app/ent/specialist"
	"github.com/team09/app/ent/title"
	"github.com/team09/app/ent/training"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse     = "Course"
	TypeDepartment = "Department"
	TypeDisease    = "Disease"
	TypeDoctor     = "Doctor"
	TypeGender     = "Gender"
	TypeMission    = "Mission"
	TypeOffice     = "Office"
	TypePosition   = "Position"
	TypeSchedule   = "Schedule"
	TypeSpecialist = "Specialist"
	TypeTitle      = "Title"
	TypeTraining   = "Training"
)

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op               Op
	typ              string
	id               *int
	namecourse       *string
	clearedFields    map[string]struct{}
	trainings        map[int]struct{}
	removedtrainings map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNamecourse sets the namecourse field.
func (m *CourseMutation) SetNamecourse(s string) {
	m.namecourse = &s
}

// Namecourse returns the namecourse value in the mutation.
func (m *CourseMutation) Namecourse() (r string, exists bool) {
	v := m.namecourse
	if v == nil {
		return
	}
	return *v, true
}

// OldNamecourse returns the old namecourse value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldNamecourse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNamecourse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNamecourse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamecourse: %w", err)
	}
	return oldValue.Namecourse, nil
}

// ResetNamecourse reset all changes of the "namecourse" field.
func (m *CourseMutation) ResetNamecourse() {
	m.namecourse = nil
}

// AddTrainingIDs adds the trainings edge to Training by ids.
func (m *CourseMutation) AddTrainingIDs(ids ...int) {
	if m.trainings == nil {
		m.trainings = make(map[int]struct{})
	}
	for i := range ids {
		m.trainings[ids[i]] = struct{}{}
	}
}

// RemoveTrainingIDs removes the trainings edge to Training by ids.
func (m *CourseMutation) RemoveTrainingIDs(ids ...int) {
	if m.removedtrainings == nil {
		m.removedtrainings = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtrainings[ids[i]] = struct{}{}
	}
}

// RemovedTrainings returns the removed ids of trainings.
func (m *CourseMutation) RemovedTrainingsIDs() (ids []int) {
	for id := range m.removedtrainings {
		ids = append(ids, id)
	}
	return
}

// TrainingsIDs returns the trainings ids in the mutation.
func (m *CourseMutation) TrainingsIDs() (ids []int) {
	for id := range m.trainings {
		ids = append(ids, id)
	}
	return
}

// ResetTrainings reset all changes of the "trainings" edge.
func (m *CourseMutation) ResetTrainings() {
	m.trainings = nil
	m.removedtrainings = nil
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.namecourse != nil {
		fields = append(fields, course.FieldNamecourse)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldNamecourse:
		return m.Namecourse()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldNamecourse:
		return m.OldNamecourse(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldNamecourse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamecourse(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldNamecourse:
		m.ResetNamecourse()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.trainings != nil {
		edges = append(edges, course.EdgeTrainings)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.trainings))
		for id := range m.trainings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtrainings != nil {
		edges = append(edges, course.EdgeTrainings)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.removedtrainings))
		for id := range m.removedtrainings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeTrainings:
		m.ResetTrainings()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Detail            *string
	_Name              *string
	clearedFields      map[string]struct{}
	mission            *int
	clearedmission     bool
	doctor             *int
	cleareddoctor      bool
	offices            map[int]struct{}
	removedoffices     map[int]struct{}
	schedules          map[int]struct{}
	removedschedules   map[int]struct{}
	trainings          map[int]struct{}
	removedtrainings   map[int]struct{}
	specialists        map[int]struct{}
	removedspecialists map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDetail sets the Detail field.
func (m *DepartmentMutation) SetDetail(s string) {
	m._Detail = &s
}

// Detail returns the Detail value in the mutation.
func (m *DepartmentMutation) Detail() (r string, exists bool) {
	v := m._Detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old Detail value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail reset all changes of the "Detail" field.
func (m *DepartmentMutation) ResetDetail() {
	m._Detail = nil
}

// SetName sets the Name field.
func (m *DepartmentMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *DepartmentMutation) ResetName() {
	m._Name = nil
}

// SetMissionID sets the mission edge to Mission by id.
func (m *DepartmentMutation) SetMissionID(id int) {
	m.mission = &id
}

// ClearMission clears the mission edge to Mission.
func (m *DepartmentMutation) ClearMission() {
	m.clearedmission = true
}

// MissionCleared returns if the edge mission was cleared.
func (m *DepartmentMutation) MissionCleared() bool {
	return m.clearedmission
}

// MissionID returns the mission id in the mutation.
func (m *DepartmentMutation) MissionID() (id int, exists bool) {
	if m.mission != nil {
		return *m.mission, true
	}
	return
}

// MissionIDs returns the mission ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MissionID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) MissionIDs() (ids []int) {
	if id := m.mission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMission reset all changes of the "mission" edge.
func (m *DepartmentMutation) ResetMission() {
	m.mission = nil
	m.clearedmission = false
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *DepartmentMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *DepartmentMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *DepartmentMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *DepartmentMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *DepartmentMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// AddOfficeIDs adds the offices edge to Office by ids.
func (m *DepartmentMutation) AddOfficeIDs(ids ...int) {
	if m.offices == nil {
		m.offices = make(map[int]struct{})
	}
	for i := range ids {
		m.offices[ids[i]] = struct{}{}
	}
}

// RemoveOfficeIDs removes the offices edge to Office by ids.
func (m *DepartmentMutation) RemoveOfficeIDs(ids ...int) {
	if m.removedoffices == nil {
		m.removedoffices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoffices[ids[i]] = struct{}{}
	}
}

// RemovedOffices returns the removed ids of offices.
func (m *DepartmentMutation) RemovedOfficesIDs() (ids []int) {
	for id := range m.removedoffices {
		ids = append(ids, id)
	}
	return
}

// OfficesIDs returns the offices ids in the mutation.
func (m *DepartmentMutation) OfficesIDs() (ids []int) {
	for id := range m.offices {
		ids = append(ids, id)
	}
	return
}

// ResetOffices reset all changes of the "offices" edge.
func (m *DepartmentMutation) ResetOffices() {
	m.offices = nil
	m.removedoffices = nil
}

// AddScheduleIDs adds the schedules edge to Schedule by ids.
func (m *DepartmentMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// RemoveScheduleIDs removes the schedules edge to Schedule by ids.
func (m *DepartmentMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed ids of schedules.
func (m *DepartmentMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the schedules ids in the mutation.
func (m *DepartmentMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules reset all changes of the "schedules" edge.
func (m *DepartmentMutation) ResetSchedules() {
	m.schedules = nil
	m.removedschedules = nil
}

// AddTrainingIDs adds the trainings edge to Training by ids.
func (m *DepartmentMutation) AddTrainingIDs(ids ...int) {
	if m.trainings == nil {
		m.trainings = make(map[int]struct{})
	}
	for i := range ids {
		m.trainings[ids[i]] = struct{}{}
	}
}

// RemoveTrainingIDs removes the trainings edge to Training by ids.
func (m *DepartmentMutation) RemoveTrainingIDs(ids ...int) {
	if m.removedtrainings == nil {
		m.removedtrainings = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtrainings[ids[i]] = struct{}{}
	}
}

// RemovedTrainings returns the removed ids of trainings.
func (m *DepartmentMutation) RemovedTrainingsIDs() (ids []int) {
	for id := range m.removedtrainings {
		ids = append(ids, id)
	}
	return
}

// TrainingsIDs returns the trainings ids in the mutation.
func (m *DepartmentMutation) TrainingsIDs() (ids []int) {
	for id := range m.trainings {
		ids = append(ids, id)
	}
	return
}

// ResetTrainings reset all changes of the "trainings" edge.
func (m *DepartmentMutation) ResetTrainings() {
	m.trainings = nil
	m.removedtrainings = nil
}

// AddSpecialistIDs adds the specialists edge to Specialist by ids.
func (m *DepartmentMutation) AddSpecialistIDs(ids ...int) {
	if m.specialists == nil {
		m.specialists = make(map[int]struct{})
	}
	for i := range ids {
		m.specialists[ids[i]] = struct{}{}
	}
}

// RemoveSpecialistIDs removes the specialists edge to Specialist by ids.
func (m *DepartmentMutation) RemoveSpecialistIDs(ids ...int) {
	if m.removedspecialists == nil {
		m.removedspecialists = make(map[int]struct{})
	}
	for i := range ids {
		m.removedspecialists[ids[i]] = struct{}{}
	}
}

// RemovedSpecialists returns the removed ids of specialists.
func (m *DepartmentMutation) RemovedSpecialistsIDs() (ids []int) {
	for id := range m.removedspecialists {
		ids = append(ids, id)
	}
	return
}

// SpecialistsIDs returns the specialists ids in the mutation.
func (m *DepartmentMutation) SpecialistsIDs() (ids []int) {
	for id := range m.specialists {
		ids = append(ids, id)
	}
	return
}

// ResetSpecialists reset all changes of the "specialists" edge.
func (m *DepartmentMutation) ResetSpecialists() {
	m.specialists = nil
	m.removedspecialists = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Detail != nil {
		fields = append(fields, department.FieldDetail)
	}
	if m._Name != nil {
		fields = append(fields, department.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDetail:
		return m.Detail()
	case department.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDetail:
		return m.OldDetail(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDetail:
		m.ResetDetail()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.mission != nil {
		edges = append(edges, department.EdgeMission)
	}
	if m.doctor != nil {
		edges = append(edges, department.EdgeDoctor)
	}
	if m.offices != nil {
		edges = append(edges, department.EdgeOffices)
	}
	if m.schedules != nil {
		edges = append(edges, department.EdgeSchedules)
	}
	if m.trainings != nil {
		edges = append(edges, department.EdgeTrainings)
	}
	if m.specialists != nil {
		edges = append(edges, department.EdgeSpecialists)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeMission:
		if id := m.mission; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.offices))
		for id := range m.offices {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.trainings))
		for id := range m.trainings {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSpecialists:
		ids := make([]ent.Value, 0, len(m.specialists))
		for id := range m.specialists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedoffices != nil {
		edges = append(edges, department.EdgeOffices)
	}
	if m.removedschedules != nil {
		edges = append(edges, department.EdgeSchedules)
	}
	if m.removedtrainings != nil {
		edges = append(edges, department.EdgeTrainings)
	}
	if m.removedspecialists != nil {
		edges = append(edges, department.EdgeSpecialists)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.removedoffices))
		for id := range m.removedoffices {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.removedtrainings))
		for id := range m.removedtrainings {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeSpecialists:
		ids := make([]ent.Value, 0, len(m.removedspecialists))
		for id := range m.removedspecialists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmission {
		edges = append(edges, department.EdgeMission)
	}
	if m.cleareddoctor {
		edges = append(edges, department.EdgeDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeMission:
		return m.clearedmission
	case department.EdgeDoctor:
		return m.cleareddoctor
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeMission:
		m.ClearMission()
		return nil
	case department.EdgeDoctor:
		m.ClearDoctor()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeMission:
		m.ResetMission()
		return nil
	case department.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case department.EdgeOffices:
		m.ResetOffices()
		return nil
	case department.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case department.EdgeTrainings:
		m.ResetTrainings()
		return nil
	case department.EdgeSpecialists:
		m.ResetSpecialists()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DiseaseMutation represents an operation that mutate the Diseases
// nodes in the graph.
type DiseaseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	disease        *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Disease, error)
}

var _ ent.Mutation = (*DiseaseMutation)(nil)

// diseaseOption allows to manage the mutation configuration using functional options.
type diseaseOption func(*DiseaseMutation)

// newDiseaseMutation creates new mutation for $n.Name.
func newDiseaseMutation(c config, op Op, opts ...diseaseOption) *DiseaseMutation {
	m := &DiseaseMutation{
		config:        c,
		op:            op,
		typ:           TypeDisease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiseaseID sets the id field of the mutation.
func withDiseaseID(id int) diseaseOption {
	return func(m *DiseaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Disease
		)
		m.oldValue = func(ctx context.Context) (*Disease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisease sets the old Disease of the mutation.
func withDisease(node *Disease) diseaseOption {
	return func(m *DiseaseMutation) {
		m.oldValue = func(context.Context) (*Disease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiseaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiseaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DiseaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDisease sets the disease field.
func (m *DiseaseMutation) SetDisease(s string) {
	m.disease = &s
}

// Disease returns the disease value in the mutation.
func (m *DiseaseMutation) Disease() (r string, exists bool) {
	v := m.disease
	if v == nil {
		return
	}
	return *v, true
}

// OldDisease returns the old disease value of the Disease.
// If the Disease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseMutation) OldDisease(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisease is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisease: %w", err)
	}
	return oldValue.Disease, nil
}

// ResetDisease reset all changes of the "disease" field.
func (m *DiseaseMutation) ResetDisease() {
	m.disease = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *DiseaseMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *DiseaseMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *DiseaseMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *DiseaseMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *DiseaseMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *DiseaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disease).
func (m *DiseaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DiseaseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.disease != nil {
		fields = append(fields, disease.FieldDisease)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DiseaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disease.FieldDisease:
		return m.Disease()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DiseaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disease.FieldDisease:
		return m.OldDisease(ctx)
	}
	return nil, fmt.Errorf("unknown Disease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disease.FieldDisease:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisease(v)
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DiseaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DiseaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DiseaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DiseaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiseaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DiseaseMutation) ResetField(name string) error {
	switch name {
	case disease.FieldDisease:
		m.ResetDisease()
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DiseaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, disease.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DiseaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DiseaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, disease.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DiseaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DiseaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DiseaseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DiseaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DiseaseMutation) ResetEdge(name string) error {
	switch name {
	case disease.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Disease edge %s", name)
}

// DoctorMutation represents an operation that mutate the Doctors
// nodes in the graph.
type DoctorMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	age                *int
	addage             *int
	email              *string
	pnumber            *int
	addpnumber         *int
	address            *string
	educational        *string
	clearedFields      map[string]struct{}
	title              *int
	clearedtitle       bool
	gender             *int
	clearedgender      bool
	position           *int
	clearedposition    bool
	disease            *int
	cleareddisease     bool
	offices            map[int]struct{}
	removedoffices     map[int]struct{}
	departments        map[int]struct{}
	removeddepartments map[int]struct{}
	schedules          map[int]struct{}
	removedschedules   map[int]struct{}
	trainings          map[int]struct{}
	removedtrainings   map[int]struct{}
	specialists        map[int]struct{}
	removedspecialists map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Doctor, error)
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows to manage the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for $n.Name.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the id field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DoctorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DoctorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DoctorMutation) ResetName() {
	m.name = nil
}

// SetAge sets the age field.
func (m *DoctorMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *DoctorMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *DoctorMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *DoctorMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "age" field.
func (m *DoctorMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetEmail sets the email field.
func (m *DoctorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *DoctorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *DoctorMutation) ResetEmail() {
	m.email = nil
}

// SetPnumber sets the pnumber field.
func (m *DoctorMutation) SetPnumber(i int) {
	m.pnumber = &i
	m.addpnumber = nil
}

// Pnumber returns the pnumber value in the mutation.
func (m *DoctorMutation) Pnumber() (r int, exists bool) {
	v := m.pnumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPnumber returns the old pnumber value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldPnumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPnumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPnumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnumber: %w", err)
	}
	return oldValue.Pnumber, nil
}

// AddPnumber adds i to pnumber.
func (m *DoctorMutation) AddPnumber(i int) {
	if m.addpnumber != nil {
		*m.addpnumber += i
	} else {
		m.addpnumber = &i
	}
}

// AddedPnumber returns the value that was added to the pnumber field in this mutation.
func (m *DoctorMutation) AddedPnumber() (r int, exists bool) {
	v := m.addpnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnumber reset all changes of the "pnumber" field.
func (m *DoctorMutation) ResetPnumber() {
	m.pnumber = nil
	m.addpnumber = nil
}

// SetAddress sets the address field.
func (m *DoctorMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *DoctorMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *DoctorMutation) ResetAddress() {
	m.address = nil
}

// SetEducational sets the educational field.
func (m *DoctorMutation) SetEducational(s string) {
	m.educational = &s
}

// Educational returns the educational value in the mutation.
func (m *DoctorMutation) Educational() (r string, exists bool) {
	v := m.educational
	if v == nil {
		return
	}
	return *v, true
}

// OldEducational returns the old educational value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldEducational(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEducational is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEducational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducational: %w", err)
	}
	return oldValue.Educational, nil
}

// ResetEducational reset all changes of the "educational" field.
func (m *DoctorMutation) ResetEducational() {
	m.educational = nil
}

// SetTitleID sets the title edge to Title by id.
func (m *DoctorMutation) SetTitleID(id int) {
	m.title = &id
}

// ClearTitle clears the title edge to Title.
func (m *DoctorMutation) ClearTitle() {
	m.clearedtitle = true
}

// TitleCleared returns if the edge title was cleared.
func (m *DoctorMutation) TitleCleared() bool {
	return m.clearedtitle
}

// TitleID returns the title id in the mutation.
func (m *DoctorMutation) TitleID() (id int, exists bool) {
	if m.title != nil {
		return *m.title, true
	}
	return
}

// TitleIDs returns the title ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TitleID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) TitleIDs() (ids []int) {
	if id := m.title; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTitle reset all changes of the "title" edge.
func (m *DoctorMutation) ResetTitle() {
	m.title = nil
	m.clearedtitle = false
}

// SetGenderID sets the gender edge to Gender by id.
func (m *DoctorMutation) SetGenderID(id int) {
	m.gender = &id
}

// ClearGender clears the gender edge to Gender.
func (m *DoctorMutation) ClearGender() {
	m.clearedgender = true
}

// GenderCleared returns if the edge gender was cleared.
func (m *DoctorMutation) GenderCleared() bool {
	return m.clearedgender
}

// GenderID returns the gender id in the mutation.
func (m *DoctorMutation) GenderID() (id int, exists bool) {
	if m.gender != nil {
		return *m.gender, true
	}
	return
}

// GenderIDs returns the gender ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) GenderIDs() (ids []int) {
	if id := m.gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender reset all changes of the "gender" edge.
func (m *DoctorMutation) ResetGender() {
	m.gender = nil
	m.clearedgender = false
}

// SetPositionID sets the position edge to Position by id.
func (m *DoctorMutation) SetPositionID(id int) {
	m.position = &id
}

// ClearPosition clears the position edge to Position.
func (m *DoctorMutation) ClearPosition() {
	m.clearedposition = true
}

// PositionCleared returns if the edge position was cleared.
func (m *DoctorMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionID returns the position id in the mutation.
func (m *DoctorMutation) PositionID() (id int, exists bool) {
	if m.position != nil {
		return *m.position, true
	}
	return
}

// PositionIDs returns the position ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) PositionIDs() (ids []int) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition reset all changes of the "position" edge.
func (m *DoctorMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// SetDiseaseID sets the disease edge to Disease by id.
func (m *DoctorMutation) SetDiseaseID(id int) {
	m.disease = &id
}

// ClearDisease clears the disease edge to Disease.
func (m *DoctorMutation) ClearDisease() {
	m.cleareddisease = true
}

// DiseaseCleared returns if the edge disease was cleared.
func (m *DoctorMutation) DiseaseCleared() bool {
	return m.cleareddisease
}

// DiseaseID returns the disease id in the mutation.
func (m *DoctorMutation) DiseaseID() (id int, exists bool) {
	if m.disease != nil {
		return *m.disease, true
	}
	return
}

// DiseaseIDs returns the disease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DiseaseID instead. It exists only for internal usage by the builders.
func (m *DoctorMutation) DiseaseIDs() (ids []int) {
	if id := m.disease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDisease reset all changes of the "disease" edge.
func (m *DoctorMutation) ResetDisease() {
	m.disease = nil
	m.cleareddisease = false
}

// AddOfficeIDs adds the offices edge to Office by ids.
func (m *DoctorMutation) AddOfficeIDs(ids ...int) {
	if m.offices == nil {
		m.offices = make(map[int]struct{})
	}
	for i := range ids {
		m.offices[ids[i]] = struct{}{}
	}
}

// RemoveOfficeIDs removes the offices edge to Office by ids.
func (m *DoctorMutation) RemoveOfficeIDs(ids ...int) {
	if m.removedoffices == nil {
		m.removedoffices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoffices[ids[i]] = struct{}{}
	}
}

// RemovedOffices returns the removed ids of offices.
func (m *DoctorMutation) RemovedOfficesIDs() (ids []int) {
	for id := range m.removedoffices {
		ids = append(ids, id)
	}
	return
}

// OfficesIDs returns the offices ids in the mutation.
func (m *DoctorMutation) OfficesIDs() (ids []int) {
	for id := range m.offices {
		ids = append(ids, id)
	}
	return
}

// ResetOffices reset all changes of the "offices" edge.
func (m *DoctorMutation) ResetOffices() {
	m.offices = nil
	m.removedoffices = nil
}

// AddDepartmentIDs adds the departments edge to Department by ids.
func (m *DoctorMutation) AddDepartmentIDs(ids ...int) {
	if m.departments == nil {
		m.departments = make(map[int]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentIDs removes the departments edge to Department by ids.
func (m *DoctorMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed ids of departments.
func (m *DoctorMutation) RemovedDepartmentsIDs() (ids []int) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the departments ids in the mutation.
func (m *DoctorMutation) DepartmentsIDs() (ids []int) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments reset all changes of the "departments" edge.
func (m *DoctorMutation) ResetDepartments() {
	m.departments = nil
	m.removeddepartments = nil
}

// AddScheduleIDs adds the schedules edge to Schedule by ids.
func (m *DoctorMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// RemoveScheduleIDs removes the schedules edge to Schedule by ids.
func (m *DoctorMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed ids of schedules.
func (m *DoctorMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the schedules ids in the mutation.
func (m *DoctorMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules reset all changes of the "schedules" edge.
func (m *DoctorMutation) ResetSchedules() {
	m.schedules = nil
	m.removedschedules = nil
}

// AddTrainingIDs adds the trainings edge to Training by ids.
func (m *DoctorMutation) AddTrainingIDs(ids ...int) {
	if m.trainings == nil {
		m.trainings = make(map[int]struct{})
	}
	for i := range ids {
		m.trainings[ids[i]] = struct{}{}
	}
}

// RemoveTrainingIDs removes the trainings edge to Training by ids.
func (m *DoctorMutation) RemoveTrainingIDs(ids ...int) {
	if m.removedtrainings == nil {
		m.removedtrainings = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtrainings[ids[i]] = struct{}{}
	}
}

// RemovedTrainings returns the removed ids of trainings.
func (m *DoctorMutation) RemovedTrainingsIDs() (ids []int) {
	for id := range m.removedtrainings {
		ids = append(ids, id)
	}
	return
}

// TrainingsIDs returns the trainings ids in the mutation.
func (m *DoctorMutation) TrainingsIDs() (ids []int) {
	for id := range m.trainings {
		ids = append(ids, id)
	}
	return
}

// ResetTrainings reset all changes of the "trainings" edge.
func (m *DoctorMutation) ResetTrainings() {
	m.trainings = nil
	m.removedtrainings = nil
}

// AddSpecialistIDs adds the specialists edge to Specialist by ids.
func (m *DoctorMutation) AddSpecialistIDs(ids ...int) {
	if m.specialists == nil {
		m.specialists = make(map[int]struct{})
	}
	for i := range ids {
		m.specialists[ids[i]] = struct{}{}
	}
}

// RemoveSpecialistIDs removes the specialists edge to Specialist by ids.
func (m *DoctorMutation) RemoveSpecialistIDs(ids ...int) {
	if m.removedspecialists == nil {
		m.removedspecialists = make(map[int]struct{})
	}
	for i := range ids {
		m.removedspecialists[ids[i]] = struct{}{}
	}
}

// RemovedSpecialists returns the removed ids of specialists.
func (m *DoctorMutation) RemovedSpecialistsIDs() (ids []int) {
	for id := range m.removedspecialists {
		ids = append(ids, id)
	}
	return
}

// SpecialistsIDs returns the specialists ids in the mutation.
func (m *DoctorMutation) SpecialistsIDs() (ids []int) {
	for id := range m.specialists {
		ids = append(ids, id)
	}
	return
}

// ResetSpecialists reset all changes of the "specialists" edge.
func (m *DoctorMutation) ResetSpecialists() {
	m.specialists = nil
	m.removedspecialists = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, doctor.FieldName)
	}
	if m.age != nil {
		fields = append(fields, doctor.FieldAge)
	}
	if m.email != nil {
		fields = append(fields, doctor.FieldEmail)
	}
	if m.pnumber != nil {
		fields = append(fields, doctor.FieldPnumber)
	}
	if m.address != nil {
		fields = append(fields, doctor.FieldAddress)
	}
	if m.educational != nil {
		fields = append(fields, doctor.FieldEducational)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldName:
		return m.Name()
	case doctor.FieldAge:
		return m.Age()
	case doctor.FieldEmail:
		return m.Email()
	case doctor.FieldPnumber:
		return m.Pnumber()
	case doctor.FieldAddress:
		return m.Address()
	case doctor.FieldEducational:
		return m.Educational()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldName:
		return m.OldName(ctx)
	case doctor.FieldAge:
		return m.OldAge(ctx)
	case doctor.FieldEmail:
		return m.OldEmail(ctx)
	case doctor.FieldPnumber:
		return m.OldPnumber(ctx)
	case doctor.FieldAddress:
		return m.OldAddress(ctx)
	case doctor.FieldEducational:
		return m.OldEducational(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case doctor.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case doctor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case doctor.FieldPnumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnumber(v)
		return nil
	case doctor.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case doctor.FieldEducational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducational(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, doctor.FieldAge)
	}
	if m.addpnumber != nil {
		fields = append(fields, doctor.FieldPnumber)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldAge:
		return m.AddedAge()
	case doctor.FieldPnumber:
		return m.AddedPnumber()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case doctor.FieldPnumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnumber(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldName:
		m.ResetName()
		return nil
	case doctor.FieldAge:
		m.ResetAge()
		return nil
	case doctor.FieldEmail:
		m.ResetEmail()
		return nil
	case doctor.FieldPnumber:
		m.ResetPnumber()
		return nil
	case doctor.FieldAddress:
		m.ResetAddress()
		return nil
	case doctor.FieldEducational:
		m.ResetEducational()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.title != nil {
		edges = append(edges, doctor.EdgeTitle)
	}
	if m.gender != nil {
		edges = append(edges, doctor.EdgeGender)
	}
	if m.position != nil {
		edges = append(edges, doctor.EdgePosition)
	}
	if m.disease != nil {
		edges = append(edges, doctor.EdgeDisease)
	}
	if m.offices != nil {
		edges = append(edges, doctor.EdgeOffices)
	}
	if m.departments != nil {
		edges = append(edges, doctor.EdgeDepartments)
	}
	if m.schedules != nil {
		edges = append(edges, doctor.EdgeSchedules)
	}
	if m.trainings != nil {
		edges = append(edges, doctor.EdgeTrainings)
	}
	if m.specialists != nil {
		edges = append(edges, doctor.EdgeSpecialists)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeTitle:
		if id := m.title; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeGender:
		if id := m.gender; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeDisease:
		if id := m.disease; id != nil {
			return []ent.Value{*id}
		}
	case doctor.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.offices))
		for id := range m.offices {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.trainings))
		for id := range m.trainings {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSpecialists:
		ids := make([]ent.Value, 0, len(m.specialists))
		for id := range m.specialists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedoffices != nil {
		edges = append(edges, doctor.EdgeOffices)
	}
	if m.removeddepartments != nil {
		edges = append(edges, doctor.EdgeDepartments)
	}
	if m.removedschedules != nil {
		edges = append(edges, doctor.EdgeSchedules)
	}
	if m.removedtrainings != nil {
		edges = append(edges, doctor.EdgeTrainings)
	}
	if m.removedspecialists != nil {
		edges = append(edges, doctor.EdgeSpecialists)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.removedoffices))
		for id := range m.removedoffices {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeTrainings:
		ids := make([]ent.Value, 0, len(m.removedtrainings))
		for id := range m.removedtrainings {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeSpecialists:
		ids := make([]ent.Value, 0, len(m.removedspecialists))
		for id := range m.removedspecialists {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedtitle {
		edges = append(edges, doctor.EdgeTitle)
	}
	if m.clearedgender {
		edges = append(edges, doctor.EdgeGender)
	}
	if m.clearedposition {
		edges = append(edges, doctor.EdgePosition)
	}
	if m.cleareddisease {
		edges = append(edges, doctor.EdgeDisease)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	case doctor.EdgeTitle:
		return m.clearedtitle
	case doctor.EdgeGender:
		return m.clearedgender
	case doctor.EdgePosition:
		return m.clearedposition
	case doctor.EdgeDisease:
		return m.cleareddisease
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	case doctor.EdgeTitle:
		m.ClearTitle()
		return nil
	case doctor.EdgeGender:
		m.ClearGender()
		return nil
	case doctor.EdgePosition:
		m.ClearPosition()
		return nil
	case doctor.EdgeDisease:
		m.ClearDisease()
		return nil
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeTitle:
		m.ResetTitle()
		return nil
	case doctor.EdgeGender:
		m.ResetGender()
		return nil
	case doctor.EdgePosition:
		m.ResetPosition()
		return nil
	case doctor.EdgeDisease:
		m.ResetDisease()
		return nil
	case doctor.EdgeOffices:
		m.ResetOffices()
		return nil
	case doctor.EdgeDepartments:
		m.ResetDepartments()
		return nil
	case doctor.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case doctor.EdgeTrainings:
		m.ResetTrainings()
		return nil
	case doctor.EdgeSpecialists:
		m.ResetSpecialists()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op             Op
	typ            string
	id             *int
	gender         *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGender sets the gender field.
func (m *GenderMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the gender value in the mutation.
func (m *GenderMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *GenderMutation) ResetGender() {
	m.gender = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *GenderMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *GenderMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *GenderMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *GenderMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *GenderMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.gender != nil {
		fields = append(fields, gender.FieldGender)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGender:
		return m.Gender()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGender:
		return m.OldGender(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGender:
		m.ResetGender()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, gender.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, gender.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// MissionMutation represents an operation that mutate the Missions
// nodes in the graph.
type MissionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_MissionType       *string
	clearedFields      map[string]struct{}
	departments        map[int]struct{}
	removeddepartments map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Mission, error)
}

var _ ent.Mutation = (*MissionMutation)(nil)

// missionOption allows to manage the mutation configuration using functional options.
type missionOption func(*MissionMutation)

// newMissionMutation creates new mutation for $n.Name.
func newMissionMutation(c config, op Op, opts ...missionOption) *MissionMutation {
	m := &MissionMutation{
		config:        c,
		op:            op,
		typ:           TypeMission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMissionID sets the id field of the mutation.
func withMissionID(id int) missionOption {
	return func(m *MissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Mission
		)
		m.oldValue = func(ctx context.Context) (*Mission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMission sets the old Mission of the mutation.
func withMission(node *Mission) missionOption {
	return func(m *MissionMutation) {
		m.oldValue = func(context.Context) (*Mission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMissionType sets the MissionType field.
func (m *MissionMutation) SetMissionType(s string) {
	m._MissionType = &s
}

// MissionType returns the MissionType value in the mutation.
func (m *MissionMutation) MissionType() (r string, exists bool) {
	v := m._MissionType
	if v == nil {
		return
	}
	return *v, true
}

// OldMissionType returns the old MissionType value of the Mission.
// If the Mission object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MissionMutation) OldMissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMissionType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissionType: %w", err)
	}
	return oldValue.MissionType, nil
}

// ResetMissionType reset all changes of the "MissionType" field.
func (m *MissionMutation) ResetMissionType() {
	m._MissionType = nil
}

// AddDepartmentIDs adds the departments edge to Department by ids.
func (m *MissionMutation) AddDepartmentIDs(ids ...int) {
	if m.departments == nil {
		m.departments = make(map[int]struct{})
	}
	for i := range ids {
		m.departments[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentIDs removes the departments edge to Department by ids.
func (m *MissionMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartments == nil {
		m.removeddepartments = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartments[ids[i]] = struct{}{}
	}
}

// RemovedDepartments returns the removed ids of departments.
func (m *MissionMutation) RemovedDepartmentsIDs() (ids []int) {
	for id := range m.removeddepartments {
		ids = append(ids, id)
	}
	return
}

// DepartmentsIDs returns the departments ids in the mutation.
func (m *MissionMutation) DepartmentsIDs() (ids []int) {
	for id := range m.departments {
		ids = append(ids, id)
	}
	return
}

// ResetDepartments reset all changes of the "departments" edge.
func (m *MissionMutation) ResetDepartments() {
	m.departments = nil
	m.removeddepartments = nil
}

// Op returns the operation name.
func (m *MissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Mission).
func (m *MissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MissionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._MissionType != nil {
		fields = append(fields, mission.FieldMissionType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mission.FieldMissionType:
		return m.MissionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mission.FieldMissionType:
		return m.OldMissionType(ctx)
	}
	return nil, fmt.Errorf("unknown Mission field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mission.FieldMissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissionType(v)
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Mission nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MissionMutation) ResetField(name string) error {
	switch name {
	case mission.FieldMissionType:
		m.ResetMissionType()
		return nil
	}
	return fmt.Errorf("unknown Mission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.departments != nil {
		edges = append(edges, mission.EdgeDepartments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.departments))
		for id := range m.departments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddepartments != nil {
		edges = append(edges, mission.EdgeDepartments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mission.EdgeDepartments:
		ids := make([]ent.Value, 0, len(m.removeddepartments))
		for id := range m.removeddepartments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MissionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Mission unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MissionMutation) ResetEdge(name string) error {
	switch name {
	case mission.EdgeDepartments:
		m.ResetDepartments()
		return nil
	}
	return fmt.Errorf("unknown Mission edge %s", name)
}

// OfficeMutation represents an operation that mutate the Offices
// nodes in the graph.
type OfficeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	officename        *string
	added_time1       *time.Time
	added_time2       *time.Time
	clearedFields     map[string]struct{}
	doctor            *int
	cleareddoctor     bool
	department        *int
	cleareddepartment bool
	specialist        *int
	clearedspecialist bool
	schedules         map[int]struct{}
	removedschedules  map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Office, error)
}

var _ ent.Mutation = (*OfficeMutation)(nil)

// officeOption allows to manage the mutation configuration using functional options.
type officeOption func(*OfficeMutation)

// newOfficeMutation creates new mutation for $n.Name.
func newOfficeMutation(c config, op Op, opts ...officeOption) *OfficeMutation {
	m := &OfficeMutation{
		config:        c,
		op:            op,
		typ:           TypeOffice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOfficeID sets the id field of the mutation.
func withOfficeID(id int) officeOption {
	return func(m *OfficeMutation) {
		var (
			err   error
			once  sync.Once
			value *Office
		)
		m.oldValue = func(ctx context.Context) (*Office, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Office.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOffice sets the old Office of the mutation.
func withOffice(node *Office) officeOption {
	return func(m *OfficeMutation) {
		m.oldValue = func(context.Context) (*Office, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OfficeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OfficeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OfficeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOfficename sets the officename field.
func (m *OfficeMutation) SetOfficename(s string) {
	m.officename = &s
}

// Officename returns the officename value in the mutation.
func (m *OfficeMutation) Officename() (r string, exists bool) {
	v := m.officename
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficename returns the old officename value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldOfficename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOfficename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOfficename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficename: %w", err)
	}
	return oldValue.Officename, nil
}

// ResetOfficename reset all changes of the "officename" field.
func (m *OfficeMutation) ResetOfficename() {
	m.officename = nil
}

// SetAddedTime1 sets the added_time1 field.
func (m *OfficeMutation) SetAddedTime1(t time.Time) {
	m.added_time1 = &t
}

// AddedTime1 returns the added_time1 value in the mutation.
func (m *OfficeMutation) AddedTime1() (r time.Time, exists bool) {
	v := m.added_time1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime1 returns the old added_time1 value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldAddedTime1(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime1 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime1: %w", err)
	}
	return oldValue.AddedTime1, nil
}

// ResetAddedTime1 reset all changes of the "added_time1" field.
func (m *OfficeMutation) ResetAddedTime1() {
	m.added_time1 = nil
}

// SetAddedTime2 sets the added_time2 field.
func (m *OfficeMutation) SetAddedTime2(t time.Time) {
	m.added_time2 = &t
}

// AddedTime2 returns the added_time2 value in the mutation.
func (m *OfficeMutation) AddedTime2() (r time.Time, exists bool) {
	v := m.added_time2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime2 returns the old added_time2 value of the Office.
// If the Office object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OfficeMutation) OldAddedTime2(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime2 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime2: %w", err)
	}
	return oldValue.AddedTime2, nil
}

// ResetAddedTime2 reset all changes of the "added_time2" field.
func (m *OfficeMutation) ResetAddedTime2() {
	m.added_time2 = nil
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *OfficeMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *OfficeMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *OfficeMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *OfficeMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *OfficeMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *OfficeMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *OfficeMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *OfficeMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *OfficeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *OfficeMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *OfficeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *OfficeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetSpecialistID sets the specialist edge to Specialist by id.
func (m *OfficeMutation) SetSpecialistID(id int) {
	m.specialist = &id
}

// ClearSpecialist clears the specialist edge to Specialist.
func (m *OfficeMutation) ClearSpecialist() {
	m.clearedspecialist = true
}

// SpecialistCleared returns if the edge specialist was cleared.
func (m *OfficeMutation) SpecialistCleared() bool {
	return m.clearedspecialist
}

// SpecialistID returns the specialist id in the mutation.
func (m *OfficeMutation) SpecialistID() (id int, exists bool) {
	if m.specialist != nil {
		return *m.specialist, true
	}
	return
}

// SpecialistIDs returns the specialist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SpecialistID instead. It exists only for internal usage by the builders.
func (m *OfficeMutation) SpecialistIDs() (ids []int) {
	if id := m.specialist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpecialist reset all changes of the "specialist" edge.
func (m *OfficeMutation) ResetSpecialist() {
	m.specialist = nil
	m.clearedspecialist = false
}

// AddScheduleIDs adds the schedules edge to Schedule by ids.
func (m *OfficeMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// RemoveScheduleIDs removes the schedules edge to Schedule by ids.
func (m *OfficeMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed ids of schedules.
func (m *OfficeMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the schedules ids in the mutation.
func (m *OfficeMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules reset all changes of the "schedules" edge.
func (m *OfficeMutation) ResetSchedules() {
	m.schedules = nil
	m.removedschedules = nil
}

// Op returns the operation name.
func (m *OfficeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Office).
func (m *OfficeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OfficeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.officename != nil {
		fields = append(fields, office.FieldOfficename)
	}
	if m.added_time1 != nil {
		fields = append(fields, office.FieldAddedTime1)
	}
	if m.added_time2 != nil {
		fields = append(fields, office.FieldAddedTime2)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OfficeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case office.FieldOfficename:
		return m.Officename()
	case office.FieldAddedTime1:
		return m.AddedTime1()
	case office.FieldAddedTime2:
		return m.AddedTime2()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OfficeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case office.FieldOfficename:
		return m.OldOfficename(ctx)
	case office.FieldAddedTime1:
		return m.OldAddedTime1(ctx)
	case office.FieldAddedTime2:
		return m.OldAddedTime2(ctx)
	}
	return nil, fmt.Errorf("unknown Office field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case office.FieldOfficename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficename(v)
		return nil
	case office.FieldAddedTime1:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime1(v)
		return nil
	case office.FieldAddedTime2:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime2(v)
		return nil
	}
	return fmt.Errorf("unknown Office field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OfficeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OfficeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OfficeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Office numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OfficeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OfficeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OfficeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Office nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OfficeMutation) ResetField(name string) error {
	switch name {
	case office.FieldOfficename:
		m.ResetOfficename()
		return nil
	case office.FieldAddedTime1:
		m.ResetAddedTime1()
		return nil
	case office.FieldAddedTime2:
		m.ResetAddedTime2()
		return nil
	}
	return fmt.Errorf("unknown Office field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OfficeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.doctor != nil {
		edges = append(edges, office.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, office.EdgeDepartment)
	}
	if m.specialist != nil {
		edges = append(edges, office.EdgeSpecialist)
	}
	if m.schedules != nil {
		edges = append(edges, office.EdgeSchedules)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OfficeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case office.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case office.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case office.EdgeSpecialist:
		if id := m.specialist; id != nil {
			return []ent.Value{*id}
		}
	case office.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OfficeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedschedules != nil {
		edges = append(edges, office.EdgeSchedules)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OfficeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case office.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OfficeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddoctor {
		edges = append(edges, office.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, office.EdgeDepartment)
	}
	if m.clearedspecialist {
		edges = append(edges, office.EdgeSpecialist)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OfficeMutation) EdgeCleared(name string) bool {
	switch name {
	case office.EdgeDoctor:
		return m.cleareddoctor
	case office.EdgeDepartment:
		return m.cleareddepartment
	case office.EdgeSpecialist:
		return m.clearedspecialist
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OfficeMutation) ClearEdge(name string) error {
	switch name {
	case office.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case office.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case office.EdgeSpecialist:
		m.ClearSpecialist()
		return nil
	}
	return fmt.Errorf("unknown Office unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OfficeMutation) ResetEdge(name string) error {
	switch name {
	case office.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case office.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case office.EdgeSpecialist:
		m.ResetSpecialist()
		return nil
	case office.EdgeSchedules:
		m.ResetSchedules()
		return nil
	}
	return fmt.Errorf("unknown Office edge %s", name)
}

// PositionMutation represents an operation that mutate the Positions
// nodes in the graph.
type PositionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	position       *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Position, error)
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows to manage the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for $n.Name.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the id field of the mutation.
func withPositionID(id int) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPosition sets the position field.
func (m *PositionMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the position value in the mutation.
func (m *PositionMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old position value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPosition is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition reset all changes of the "position" field.
func (m *PositionMutation) ResetPosition() {
	m.position = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *PositionMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *PositionMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *PositionMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *PositionMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *PositionMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.position != nil {
		fields = append(fields, position.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldPosition:
		return m.OldPosition(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, position.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, position.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// ScheduleMutation represents an operation that mutate the Schedules
// nodes in the graph.
type ScheduleMutation struct {
	config
	op                Op
	typ               string
	id                *int
	activity          *string
	added_time        *time.Time
	clearedFields     map[string]struct{}
	docter            *int
	cleareddocter     bool
	department        *int
	cleareddepartment bool
	office            *int
	clearedoffice     bool
	done              bool
	oldValue          func(context.Context) (*Schedule, error)
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows to manage the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for $n.Name.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the id field of the mutation.
func withScheduleID(id int) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetActivity sets the activity field.
func (m *ScheduleMutation) SetActivity(s string) {
	m.activity = &s
}

// Activity returns the activity value in the mutation.
func (m *ScheduleMutation) Activity() (r string, exists bool) {
	v := m.activity
	if v == nil {
		return
	}
	return *v, true
}

// OldActivity returns the old activity value of the Schedule.
// If the Schedule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScheduleMutation) OldActivity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivity: %w", err)
	}
	return oldValue.Activity, nil
}

// ResetActivity reset all changes of the "activity" field.
func (m *ScheduleMutation) ResetActivity() {
	m.activity = nil
}

// SetAddedTime sets the added_time field.
func (m *ScheduleMutation) SetAddedTime(t time.Time) {
	m.added_time = &t
}

// AddedTime returns the added_time value in the mutation.
func (m *ScheduleMutation) AddedTime() (r time.Time, exists bool) {
	v := m.added_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime returns the old added_time value of the Schedule.
// If the Schedule object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScheduleMutation) OldAddedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime: %w", err)
	}
	return oldValue.AddedTime, nil
}

// ResetAddedTime reset all changes of the "added_time" field.
func (m *ScheduleMutation) ResetAddedTime() {
	m.added_time = nil
}

// SetDocterID sets the docter edge to Doctor by id.
func (m *ScheduleMutation) SetDocterID(id int) {
	m.docter = &id
}

// ClearDocter clears the docter edge to Doctor.
func (m *ScheduleMutation) ClearDocter() {
	m.cleareddocter = true
}

// DocterCleared returns if the edge docter was cleared.
func (m *ScheduleMutation) DocterCleared() bool {
	return m.cleareddocter
}

// DocterID returns the docter id in the mutation.
func (m *ScheduleMutation) DocterID() (id int, exists bool) {
	if m.docter != nil {
		return *m.docter, true
	}
	return
}

// DocterIDs returns the docter ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DocterID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) DocterIDs() (ids []int) {
	if id := m.docter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocter reset all changes of the "docter" edge.
func (m *ScheduleMutation) ResetDocter() {
	m.docter = nil
	m.cleareddocter = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *ScheduleMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *ScheduleMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *ScheduleMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *ScheduleMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *ScheduleMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetOfficeID sets the office edge to Office by id.
func (m *ScheduleMutation) SetOfficeID(id int) {
	m.office = &id
}

// ClearOffice clears the office edge to Office.
func (m *ScheduleMutation) ClearOffice() {
	m.clearedoffice = true
}

// OfficeCleared returns if the edge office was cleared.
func (m *ScheduleMutation) OfficeCleared() bool {
	return m.clearedoffice
}

// OfficeID returns the office id in the mutation.
func (m *ScheduleMutation) OfficeID() (id int, exists bool) {
	if m.office != nil {
		return *m.office, true
	}
	return
}

// OfficeIDs returns the office ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OfficeID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) OfficeIDs() (ids []int) {
	if id := m.office; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOffice reset all changes of the "office" edge.
func (m *ScheduleMutation) ResetOffice() {
	m.office = nil
	m.clearedoffice = false
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.activity != nil {
		fields = append(fields, schedule.FieldActivity)
	}
	if m.added_time != nil {
		fields = append(fields, schedule.FieldAddedTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldActivity:
		return m.Activity()
	case schedule.FieldAddedTime:
		return m.AddedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldActivity:
		return m.OldActivity(ctx)
	case schedule.FieldAddedTime:
		return m.OldAddedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldActivity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivity(v)
		return nil
	case schedule.FieldAddedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldActivity:
		m.ResetActivity()
		return nil
	case schedule.FieldAddedTime:
		m.ResetAddedTime()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.docter != nil {
		edges = append(edges, schedule.EdgeDocter)
	}
	if m.department != nil {
		edges = append(edges, schedule.EdgeDepartment)
	}
	if m.office != nil {
		edges = append(edges, schedule.EdgeOffice)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeDocter:
		if id := m.docter; id != nil {
			return []ent.Value{*id}
		}
	case schedule.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case schedule.EdgeOffice:
		if id := m.office; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddocter {
		edges = append(edges, schedule.EdgeDocter)
	}
	if m.cleareddepartment {
		edges = append(edges, schedule.EdgeDepartment)
	}
	if m.clearedoffice {
		edges = append(edges, schedule.EdgeOffice)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeDocter:
		return m.cleareddocter
	case schedule.EdgeDepartment:
		return m.cleareddepartment
	case schedule.EdgeOffice:
		return m.clearedoffice
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	case schedule.EdgeDocter:
		m.ClearDocter()
		return nil
	case schedule.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case schedule.EdgeOffice:
		m.ClearOffice()
		return nil
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeDocter:
		m.ResetDocter()
		return nil
	case schedule.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case schedule.EdgeOffice:
		m.ResetOffice()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// SpecialistMutation represents an operation that mutate the Specialists
// nodes in the graph.
type SpecialistMutation struct {
	config
	op                Op
	typ               string
	id                *int
	specialist        *string
	clearedFields     map[string]struct{}
	offices           map[int]struct{}
	removedoffices    map[int]struct{}
	doctor            *int
	cleareddoctor     bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Specialist, error)
}

var _ ent.Mutation = (*SpecialistMutation)(nil)

// specialistOption allows to manage the mutation configuration using functional options.
type specialistOption func(*SpecialistMutation)

// newSpecialistMutation creates new mutation for $n.Name.
func newSpecialistMutation(c config, op Op, opts ...specialistOption) *SpecialistMutation {
	m := &SpecialistMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecialist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecialistID sets the id field of the mutation.
func withSpecialistID(id int) specialistOption {
	return func(m *SpecialistMutation) {
		var (
			err   error
			once  sync.Once
			value *Specialist
		)
		m.oldValue = func(ctx context.Context) (*Specialist, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Specialist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecialist sets the old Specialist of the mutation.
func withSpecialist(node *Specialist) specialistOption {
	return func(m *SpecialistMutation) {
		m.oldValue = func(context.Context) (*Specialist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecialistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecialistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SpecialistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpecialist sets the specialist field.
func (m *SpecialistMutation) SetSpecialist(s string) {
	m.specialist = &s
}

// Specialist returns the specialist value in the mutation.
func (m *SpecialistMutation) Specialist() (r string, exists bool) {
	v := m.specialist
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialist returns the old specialist value of the Specialist.
// If the Specialist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SpecialistMutation) OldSpecialist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialist is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialist: %w", err)
	}
	return oldValue.Specialist, nil
}

// ResetSpecialist reset all changes of the "specialist" field.
func (m *SpecialistMutation) ResetSpecialist() {
	m.specialist = nil
}

// AddOfficeIDs adds the offices edge to Office by ids.
func (m *SpecialistMutation) AddOfficeIDs(ids ...int) {
	if m.offices == nil {
		m.offices = make(map[int]struct{})
	}
	for i := range ids {
		m.offices[ids[i]] = struct{}{}
	}
}

// RemoveOfficeIDs removes the offices edge to Office by ids.
func (m *SpecialistMutation) RemoveOfficeIDs(ids ...int) {
	if m.removedoffices == nil {
		m.removedoffices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedoffices[ids[i]] = struct{}{}
	}
}

// RemovedOffices returns the removed ids of offices.
func (m *SpecialistMutation) RemovedOfficesIDs() (ids []int) {
	for id := range m.removedoffices {
		ids = append(ids, id)
	}
	return
}

// OfficesIDs returns the offices ids in the mutation.
func (m *SpecialistMutation) OfficesIDs() (ids []int) {
	for id := range m.offices {
		ids = append(ids, id)
	}
	return
}

// ResetOffices reset all changes of the "offices" edge.
func (m *SpecialistMutation) ResetOffices() {
	m.offices = nil
	m.removedoffices = nil
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *SpecialistMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *SpecialistMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *SpecialistMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *SpecialistMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *SpecialistMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *SpecialistMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *SpecialistMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *SpecialistMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *SpecialistMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *SpecialistMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *SpecialistMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *SpecialistMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Op returns the operation name.
func (m *SpecialistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Specialist).
func (m *SpecialistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SpecialistMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.specialist != nil {
		fields = append(fields, specialist.FieldSpecialist)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SpecialistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case specialist.FieldSpecialist:
		return m.Specialist()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SpecialistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case specialist.FieldSpecialist:
		return m.OldSpecialist(ctx)
	}
	return nil, fmt.Errorf("unknown Specialist field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SpecialistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case specialist.FieldSpecialist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialist(v)
		return nil
	}
	return fmt.Errorf("unknown Specialist field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SpecialistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SpecialistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SpecialistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Specialist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SpecialistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SpecialistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecialistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Specialist nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SpecialistMutation) ResetField(name string) error {
	switch name {
	case specialist.FieldSpecialist:
		m.ResetSpecialist()
		return nil
	}
	return fmt.Errorf("unknown Specialist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SpecialistMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.offices != nil {
		edges = append(edges, specialist.EdgeOffices)
	}
	if m.doctor != nil {
		edges = append(edges, specialist.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, specialist.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SpecialistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case specialist.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.offices))
		for id := range m.offices {
			ids = append(ids, id)
		}
		return ids
	case specialist.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case specialist.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SpecialistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedoffices != nil {
		edges = append(edges, specialist.EdgeOffices)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SpecialistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case specialist.EdgeOffices:
		ids := make([]ent.Value, 0, len(m.removedoffices))
		for id := range m.removedoffices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SpecialistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddoctor {
		edges = append(edges, specialist.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, specialist.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SpecialistMutation) EdgeCleared(name string) bool {
	switch name {
	case specialist.EdgeDoctor:
		return m.cleareddoctor
	case specialist.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SpecialistMutation) ClearEdge(name string) error {
	switch name {
	case specialist.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case specialist.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Specialist unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SpecialistMutation) ResetEdge(name string) error {
	switch name {
	case specialist.EdgeOffices:
		m.ResetOffices()
		return nil
	case specialist.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case specialist.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Specialist edge %s", name)
}

// TitleMutation represents an operation that mutate the Titles
// nodes in the graph.
type TitleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	title          *string
	clearedFields  map[string]struct{}
	doctors        map[int]struct{}
	removeddoctors map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Title, error)
}

var _ ent.Mutation = (*TitleMutation)(nil)

// titleOption allows to manage the mutation configuration using functional options.
type titleOption func(*TitleMutation)

// newTitleMutation creates new mutation for $n.Name.
func newTitleMutation(c config, op Op, opts ...titleOption) *TitleMutation {
	m := &TitleMutation{
		config:        c,
		op:            op,
		typ:           TypeTitle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTitleID sets the id field of the mutation.
func withTitleID(id int) titleOption {
	return func(m *TitleMutation) {
		var (
			err   error
			once  sync.Once
			value *Title
		)
		m.oldValue = func(ctx context.Context) (*Title, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Title.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTitle sets the old Title of the mutation.
func withTitle(node *Title) titleOption {
	return func(m *TitleMutation) {
		m.oldValue = func(context.Context) (*Title, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TitleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TitleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TitleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTitle sets the title field.
func (m *TitleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *TitleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old title value of the Title.
// If the Title object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TitleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle reset all changes of the "title" field.
func (m *TitleMutation) ResetTitle() {
	m.title = nil
}

// AddDoctorIDs adds the doctors edge to Doctor by ids.
func (m *TitleMutation) AddDoctorIDs(ids ...int) {
	if m.doctors == nil {
		m.doctors = make(map[int]struct{})
	}
	for i := range ids {
		m.doctors[ids[i]] = struct{}{}
	}
}

// RemoveDoctorIDs removes the doctors edge to Doctor by ids.
func (m *TitleMutation) RemoveDoctorIDs(ids ...int) {
	if m.removeddoctors == nil {
		m.removeddoctors = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctors[ids[i]] = struct{}{}
	}
}

// RemovedDoctors returns the removed ids of doctors.
func (m *TitleMutation) RemovedDoctorsIDs() (ids []int) {
	for id := range m.removeddoctors {
		ids = append(ids, id)
	}
	return
}

// DoctorsIDs returns the doctors ids in the mutation.
func (m *TitleMutation) DoctorsIDs() (ids []int) {
	for id := range m.doctors {
		ids = append(ids, id)
	}
	return
}

// ResetDoctors reset all changes of the "doctors" edge.
func (m *TitleMutation) ResetDoctors() {
	m.doctors = nil
	m.removeddoctors = nil
}

// Op returns the operation name.
func (m *TitleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Title).
func (m *TitleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TitleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.title != nil {
		fields = append(fields, title.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TitleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case title.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TitleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case title.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Title field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case title.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TitleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TitleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TitleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Title numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TitleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TitleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TitleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Title nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TitleMutation) ResetField(name string) error {
	switch name {
	case title.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TitleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctors != nil {
		edges = append(edges, title.EdgeDoctors)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TitleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.doctors))
		for id := range m.doctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TitleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctors != nil {
		edges = append(edges, title.EdgeDoctors)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TitleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeDoctors:
		ids := make([]ent.Value, 0, len(m.removeddoctors))
		for id := range m.removeddoctors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TitleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TitleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TitleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Title unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TitleMutation) ResetEdge(name string) error {
	switch name {
	case title.EdgeDoctors:
		m.ResetDoctors()
		return nil
	}
	return fmt.Errorf("unknown Title edge %s", name)
}

// TrainingMutation represents an operation that mutate the Trainings
// nodes in the graph.
type TrainingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	branch            *string
	dateone           *time.Time
	datetwo           *time.Time
	clearedFields     map[string]struct{}
	course            *int
	clearedcourse     bool
	doctor            *int
	cleareddoctor     bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Training, error)
}

var _ ent.Mutation = (*TrainingMutation)(nil)

// trainingOption allows to manage the mutation configuration using functional options.
type trainingOption func(*TrainingMutation)

// newTrainingMutation creates new mutation for $n.Name.
func newTrainingMutation(c config, op Op, opts ...trainingOption) *TrainingMutation {
	m := &TrainingMutation{
		config:        c,
		op:            op,
		typ:           TypeTraining,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainingID sets the id field of the mutation.
func withTrainingID(id int) trainingOption {
	return func(m *TrainingMutation) {
		var (
			err   error
			once  sync.Once
			value *Training
		)
		m.oldValue = func(ctx context.Context) (*Training, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Training.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTraining sets the old Training of the mutation.
func withTraining(node *Training) trainingOption {
	return func(m *TrainingMutation) {
		m.oldValue = func(context.Context) (*Training, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TrainingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBranch sets the branch field.
func (m *TrainingMutation) SetBranch(s string) {
	m.branch = &s
}

// Branch returns the branch value in the mutation.
func (m *TrainingMutation) Branch() (r string, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranch returns the old branch value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBranch is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranch: %w", err)
	}
	return oldValue.Branch, nil
}

// ResetBranch reset all changes of the "branch" field.
func (m *TrainingMutation) ResetBranch() {
	m.branch = nil
}

// SetDateone sets the dateone field.
func (m *TrainingMutation) SetDateone(t time.Time) {
	m.dateone = &t
}

// Dateone returns the dateone value in the mutation.
func (m *TrainingMutation) Dateone() (r time.Time, exists bool) {
	v := m.dateone
	if v == nil {
		return
	}
	return *v, true
}

// OldDateone returns the old dateone value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldDateone(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateone: %w", err)
	}
	return oldValue.Dateone, nil
}

// ResetDateone reset all changes of the "dateone" field.
func (m *TrainingMutation) ResetDateone() {
	m.dateone = nil
}

// SetDatetwo sets the datetwo field.
func (m *TrainingMutation) SetDatetwo(t time.Time) {
	m.datetwo = &t
}

// Datetwo returns the datetwo value in the mutation.
func (m *TrainingMutation) Datetwo() (r time.Time, exists bool) {
	v := m.datetwo
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetwo returns the old datetwo value of the Training.
// If the Training object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TrainingMutation) OldDatetwo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetwo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetwo: %w", err)
	}
	return oldValue.Datetwo, nil
}

// ResetDatetwo reset all changes of the "datetwo" field.
func (m *TrainingMutation) ResetDatetwo() {
	m.datetwo = nil
}

// SetCourseID sets the course edge to Course by id.
func (m *TrainingMutation) SetCourseID(id int) {
	m.course = &id
}

// ClearCourse clears the course edge to Course.
func (m *TrainingMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared returns if the edge course was cleared.
func (m *TrainingMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the course id in the mutation.
func (m *TrainingMutation) CourseID() (id int, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the course ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *TrainingMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse reset all changes of the "course" edge.
func (m *TrainingMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *TrainingMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *TrainingMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *TrainingMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *TrainingMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *TrainingMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *TrainingMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *TrainingMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *TrainingMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *TrainingMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *TrainingMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *TrainingMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *TrainingMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Op returns the operation name.
func (m *TrainingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Training).
func (m *TrainingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TrainingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.branch != nil {
		fields = append(fields, training.FieldBranch)
	}
	if m.dateone != nil {
		fields = append(fields, training.FieldDateone)
	}
	if m.datetwo != nil {
		fields = append(fields, training.FieldDatetwo)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TrainingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case training.FieldBranch:
		return m.Branch()
	case training.FieldDateone:
		return m.Dateone()
	case training.FieldDatetwo:
		return m.Datetwo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TrainingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case training.FieldBranch:
		return m.OldBranch(ctx)
	case training.FieldDateone:
		return m.OldDateone(ctx)
	case training.FieldDatetwo:
		return m.OldDatetwo(ctx)
	}
	return nil, fmt.Errorf("unknown Training field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TrainingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case training.FieldBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranch(v)
		return nil
	case training.FieldDateone:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateone(v)
		return nil
	case training.FieldDatetwo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetwo(v)
		return nil
	}
	return fmt.Errorf("unknown Training field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TrainingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TrainingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TrainingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Training numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TrainingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TrainingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Training nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TrainingMutation) ResetField(name string) error {
	switch name {
	case training.FieldBranch:
		m.ResetBranch()
		return nil
	case training.FieldDateone:
		m.ResetDateone()
		return nil
	case training.FieldDatetwo:
		m.ResetDatetwo()
		return nil
	}
	return fmt.Errorf("unknown Training field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TrainingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.course != nil {
		edges = append(edges, training.EdgeCourse)
	}
	if m.doctor != nil {
		edges = append(edges, training.EdgeDoctor)
	}
	if m.department != nil {
		edges = append(edges, training.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TrainingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case training.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case training.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case training.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TrainingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TrainingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TrainingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourse {
		edges = append(edges, training.EdgeCourse)
	}
	if m.cleareddoctor {
		edges = append(edges, training.EdgeDoctor)
	}
	if m.cleareddepartment {
		edges = append(edges, training.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TrainingMutation) EdgeCleared(name string) bool {
	switch name {
	case training.EdgeCourse:
		return m.clearedcourse
	case training.EdgeDoctor:
		return m.cleareddoctor
	case training.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TrainingMutation) ClearEdge(name string) error {
	switch name {
	case training.EdgeCourse:
		m.ClearCourse()
		return nil
	case training.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case training.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Training unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TrainingMutation) ResetEdge(name string) error {
	switch name {
	case training.EdgeCourse:
		m.ResetCourse()
		return nil
	case training.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case training.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Training edge %s", name)
}
